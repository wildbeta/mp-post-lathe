[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V18.00 P4 E1 W18.00 T1419283721 M18.00 I0 O10
# Post Name           : GENERIC FANUC 4X MT_LATHE.pst
# Product             : LATHE
# Machine Name        : GENERIC FANUC
# Control Name        : GENERIC FANUC
# Description         : GENERIC FANUC LATHE C-AXIS POST
# Mill/Turn           : YES
# 4-axis/Axis subs.   : YES
# 5-axis              : NO
# Subprograms         : YES
# Canned Cycles       : YES
# Executable          : MP 18.0
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# Associated File List$
#
# GENERIC FANUC 4X MT_LATHE.control-9
#
# Associated File List$
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# CNC 07/07/05  -  Initial post update for Mastercam X
# CNC 06/26/06  -  Initial post update for Mastercam X2
# CNC 02/20/07  -  Modified pcoutrev to fix full arc output with c-axis bug.
# CNC 02/26/07  -  Modified pwcs
# CNC 04/08/08  -  X3 release - Removed check for write_ops
# CNC 09/03/08  -  Added separate variables for initial break arcs values.
# CNC 01/26/09  -  Initial post update for Mastercam X4
# CNC 07/14/09  -  Added Flag for Misc Operation when its the first operation to Post
# CNC 12/07/09  -  Added fix for P & Q  when using Sequence number in lathe canned cycles
# CNC 02/03/10  -  Initial post update for Mastercam X5
# CNC 08/17/10  -  Added fix for X coolant output
#               -  Added fix for MP line break pattern
#               -  Removed CD_VAR variables
#               -  Added axis sub direction logic
# CNC 08/18/10  -  Improved Cutter Comp for Lathe canned turning (See New Feature for X5)
#               -  Modified Misc Operation flag name
# CNC 08/23/10  -  Added logic to handle axis sub with signed or shortest direction and rotation >= 360 degrees
# CNC 12/02/10  -  Added fix for axis substitution logic
#               -  Added fix for acceleration clearance distance when threading on Sub-Spindle
# CNC 02/17/11  -  Added four arctype$ initialization variables that are used for
#                  full arc and helix arc output, when CD is set to R or signed R
# CNC 05/20/11  -  Initial post update for Mastercam X6
# CNC 06/27/11  -  Modified pstck_trans$ and pchuck$ to account for the new Cutoff/Barpull/Pickoff utility
# CNC 07/26/11  -  Added logic to handle Lead in/out for Polar interpolation (G112/G113)
# CNC 09/02/11  -  Modified pcoutrev to fix potential endless loop when processing axis sub
# CNC 09/12/11  -  Modified buffer read/write logic
# CNC 09/16/11  -  Modify pdrlcommonb to properly handle spindle direction in drill cycles
# CNC 10/20/11  -  Supress adding the sweep$ value when milling a linearized arc on the face.
# CNC 03/06/12  -  Added support for CD option 'Subprograms before / after main program'.  This includes modifications
#                    to send lathe canned cycles to the new lcc file instead of the ext file that was previously used.
# CNC 07/24/12  -  X coolant 'With' - separated coolant 'with' logic from cantext 'with' logic to give
#                    more control over output location of X coolant 'With'.  See pcan1 and pcan1_cool
# CNC 08/21/12  -  Added fix for pattern repeat output (G73)
# CNC 10/16/12  -  Initial post update for Mastercam X7
# CNC 06/03/14  -  Lathe thread cycle revisions - pfr_l, pthread0$, pg76$, psetup.  Revisions affect feed address,
#                  R value on tapered thread, end point of tapered thread, format of Q&R on second line of G76
# CNC 02/06/14  -  Initial post update for Mastercam X8
# CNC 10/07/14  -  Added fix for face cut in prapidout
# CNC 12/23/14  -  Initial post update for Mastercam X9
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
#######          MILL/TURN FUNCTIONS SUPPORTED BY THIS POST          #######
#
# This post supports Generic Fanuc code output for mill/turn lathes.
# It is designed to support the features of Mastercam X.
#
## NEW FEATURES FOR X6
# - Support for the new Cutoff/Barpull/Pickoff utility has been added in the pstck_trans$ and pchuck$ postblocks.
#    some additional options have been added inside the Misc. Op Custom Parameters to account for Reposition
#    in Feed or Rapid mode, dwell and Feedrate amount.
#    miscops_mi1$ will activate the utility logic in a stock transfer operation
# - Sub-program support
#     Choose the location of subprogram output using the Control Definition options
#     'Subprograms after main program' or 'Subprograms before main program'
#
## NEW FEATURES FOR X5
# - Improved algorithm for Lathe canned turning. This lets you output the Cutter Comp code
#    for the Lead in/out move either outside or inside the canned macro. This lets you choose
#    which method to use based on the specific machine requirements (see slcc_options below).
#
## NEW FEATURES FOR X
# - Machine definition, control definition and toolpath group parameter read sections added.
# - Variable initialization with SET_BY_MD or SET_BY_CD are overwritten in this post by parameter or
#     variable settings from MD or CD.
# - Enhanced tool information - Added switch for tool comments (see tool_info)
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
# - Additional date, time and data path output options (see pheader)
# - Support for 10 additional canned text options for X
# - Decimal support for sequence number output (set "Increment sequence number" in CD to a decimal value
#     for output.  I.E. "Increment sequence number" = .5, "Start sequence number" = 10 : N10, N10.5, N11, N11.5, etc...)
# - Switch for output of M00 or M01 at tool change (3 position switch, off, M00, M01 - see prog_stop)
# - Support for seperate XY, XZ and YZ plane/arc variables (see Arc page in CD)
# - Support for X style coolant.  Allows up to 10 different coolants to be turned on/off before, with, or after like
#     canned text.  Coolant output is handled by "coolant" variable and string selector for V9 style coolant,
#     "coolantx" variable and string selector for X style coolant.
#
# Following Misc. Integers are used:
#
# mi1 - Work coordinate system: (home_type)
#       -1 = Reference return / Tool offset positioning.
#       0 = G50 with the X and Z home positions.
#       1 = X and Z home positions.
#       2 = WCS of G54, G55.... based on Mastercam settings.
#
# mi2 - Absolute or Incremental positioning at top level
#       0 = absolute
#       1 = incremental
#
# mi3 - Select G28 or G30 reference point return:
#       0 = G28, 1 = G30
#
# mi4 - Canned conversion cycle type selection:
#       Mill-
#       Activates milling axis conversation canned cycles (G107 or G112).
#       1 or -1 activates the cycle, the path continues until next entry is
#       zero, sign switches (1 to -1) forces g113 at null toolchnge, the
#       cycle changes or the tool changes.
#
# --------------------------------------------------------------------------
# Lathe Misc. Op Custom Parameters (Misc. Values):
# --------------------------------------------------------------------------
# Stock Transfer Operation
#
# Integers:
#
# mi1 - Use Cutoff/Barpull/Pickoff utility
#        0 = No
#        1 = Yes
#
# mi2 - (Reserved - Do not edit)
#
# mi3 - mi10 (NOT USED)
#
# Reals:
#
# mr1 - mr2 (Reserved - Do not edit)
#
# mr3 - mr10 (NOT USED)
#
# --------------------------------------------------------------------------
# Chuck Operation
#
# Integers:
#
# mi1 - (Reserved - Do not edit)
#
# mi2 - Reposition Mode [0=Rapid,1=Feed]
#        0 = Rapid Move (G0)
#        1 = Linear Feed (G1)
#
# Reals:
#
# mr1 - Chuck Clamp/Unclamp Dwell Time
#
# mr2 - Feedrate Amount [0=Default >0=Value]
#        Reposition Feedrate - when mi2 = 1
#        0 = Use post default (set in miscop_feedrate initialization)
#        >0 = Use value
#
# mr3 - mr10 (NOT USED)
#
# --------------------------------------------------------------------------
#Canned text:
#  Entering cantext within Mastercam allows the following functions to
#  enable/disable.
#  cantext value:
#  1 = Program Stop =  output the "M00" stop code
#  2 = Optional Stop = output the "M01" optional stop code
#  3 = Block Delete on = turn on block delete codes in NC lines
#  4 = Block Delete off = turn off block delete codes in NC lines
#  5 = Return Tailstock =  output the code to retract the tail stock
#  6 = Advance Tailstock =  output the code to advance the tail stock
#  7 = Return Chute =  output the code to retract the chute
#  8 = Advance Chute =  output the code to advance the chute
#  9 = Exact Stop on = turn on the exact stop code in the NC line
#  10 = Exact Stop off = turn off the exact stop code in the NC line
#  11 to 99 output the value selected
#
#TURN TOOLPATHS:
#Lathe canned cycles:
# Supports lathe canned turning cycles through Mastercam.  This post
# is configured to process them.
#
#MILL TOOLPATHS:
#Mill Layout:
# The term "Reference View" refers to the coordinate system associated
# with the Mill Top view (Alt-F9, the upper gnomon of the three displayed).
# Create the part drawing with the the axis of rotation along the X axis
# of the "Mill Reference View" with the face of the part toward the side
# view (Mill Reference View X plus direction).  The Y plus axis of the
# Mill Reference View indicates the position on the part of C zero
# (View number 3).  The right or left side view are the only legal views
# for face milling.  The view number 3 rotated about the X axis as a
# "single axis rotation" are the only legal views for cross milling
# except for axis substitution where the top view is required.
# Rotation around the part is positive in the CCW direction when viewed
# from the side view.
# (The Chook 'CVIEW' should be used for creating milling tool plane and
# construction plane selections, C axis toolpaths in lathe perform
# this function automatically).
#NOTICE: View number 3 always indicates the location for C zero.  Milling
#        with a turret below the centerline indicates C at 180 degrees.
#
#Mill canned cycles:
#Cylindrical interpolation, G107 canned cycle:
# Cylindrical interpolation is created with axis substitution only.
# Use the Caxis/C_axis Contour toolpath.  Create the geometry from
# view number 4 if the rotation of C axis is CCW.  This prevents producing
# a mirror image.  Wrapped and unwrapped geometry are broken and arcs are
# lost so it is better to create flattened geometry.  Set the parameters
# in Rotary Axis not to 'unroll' and set the correct diameter.
# Use View number 3 as the C0 location.  Set mi4 to activate!
#
#Polar interpolation, G112 canned cycle:
# Polar interpolation is active only for face cutting (Right or Left).
# Use the Caxis/Face Contour toolpath. All paths must start and end at
# the 'C0'location for output to be correct. Chain geometry and set
# mi4 to activate G112 mode!
#
#Axis substitution:
# View number 3 is the C zero location on the part and corresponds to the
# Y zero position of the "Mill Reference View".  Positions are wrapped
# from and to the diameter of the part as CCW for the Y positive direction.
# If geometry is drawn from View number 4 (Bottom), it is correct for the
# wrap/unwrap on the diameter.  The radius of the specified diameter is
# added to the Z position in the post.  The Y axis is the only axis to
# be converted with mill/turn.
#
#Simultaneous 4 Axis (11 gcode):
# Full 4 axis toolpaths can be generated from various toolpaths under the
# 'multi-axis' selection (i.e. Rotary 4 axis). All 5 axis paths are
# converted to 4 axis paths where only the angle about the rotation axis
# is resolved. Use View number 3 for the toolplane with all 'multi-axis'.
# 4 and 5 axis toolpaths are converted assuming cross machining only!
#
#Y axis output and machining over part center:
# Output Y axis motion by setting 'Rotary axis/Y axis' in the NC
# parameter page.  This requires a valid Axis Combination in your machine defintion.
# y_axis_mch is set from the axis combination.
# Set 'Rotary axis/Y axis' in a machine with no Y axis (y_axis_mch = 0)
# to force linear/circular position moves in the XZ plane (g18).
# This allows machining over the part center.
#Caution: The machining must stay in the XZ plane at a Y fixed value
# when y_axis_mch = zero because no C (other than the Tplane) or
# Y positions are output!!!  This occurs when selecting C_axis/Cross
# Contour without 'y_axis_mch'.  Use Mill toolpaths for cross profiling.
#
#NOTICE: Milling through the part center with a linear move requires the
#        geometry be broken at the centerline.  Milling through the part
#        center with an arc move in the G18 plane, no Y axis and on the
#        negative side of X, reverses only the arc direction and I sign.
#
#Additional Notes:
# 1) G54 calls are generated where the work offset entry of 0 = G54,
#    1 = G55, etc.
# 2) Metric is applied from the NCI met_tool variable.
# 3) The Tplane angle is added to polar conversion and rotary paths.
# 4) The variable 'absinc' is now pre-defined, set mi2 (Misc. Integer) for
#    the 'top level' absolute/incremental program output.  Subprograms are
#    updated through the Mastercam dialog settings for sub-programs.
# 5) Lathe disables coordinate mirror and rotate subprograms.
# 6) When creating tools the diameter/radius should end as even numbers
#    relative to the machine precision. EX. Enter 1.0002 dia. and not
#    1.0001 dia. with a machine accuracy of .0001.
# 7) Transform subprograms are intended for use with G54... workshifts.
# 8) Incremental motion at a toolchange is calculated from the values
#    entered for home position.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and program switches
# --------------------------------------------------------------------------
m_one        := -1   #Define constant
zero         := 0    #Define constant
one          := 1    #Define constant
two          := 2    #Define constant
three        := 3    #Define constant
four         := 4    #Define constant
five         := 5    #Define constant
six          := 6    #Define constant
c9k          := 9999 #Define constant

bug4$        : 1     #Debug output with the tilde '~'.
                     #A value greater the zero applies the variable formatting with
                     #debug output (default is typically FS 1 but not a guarantee).
                     #A value of zero gets the value directly with NO formatting.

linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 0     #Associate X plane specific variables to V9- variable?
linklvar$    : 0     #Associate X lathe specific variables to V9- variable?

skp_lead_flgs$ : 1   #Do NOT use v9 style contour flags
sx_support_mc$ : "10"#Enable new pickoff/cutoff functionality
get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
tlchng_aft$  : 2     #Delay call to toolchange until move line
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
cc_1013$     : 1     #Read cc_pos on the 1013 line, lathe

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
# The following four initializations are used for full arc and helix arc output when the CD
#   is set to output R or signed R for arcs
larctypexz$  : 2     #Lathe Arc center type XZ plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.
arctype$     : 2     #Mill Arc center type XY plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.
arctypexz$   : 2     #Mill Arc center type XZ plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.
arctypeyz$   : 2     #Mill Arc center type YZ plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.

maxfeedpm    : 500   #Limit for feed in inch/min
vtol_m       : 0.0025#System tolerance, metric
maxfeedpm_m  : 10000 #Limit for feed in mm/min
force_wcs    : yes$  #Force WCS output at every toolchange?
progname$    : 1     #Use uppercase for program name
rotaxtyp$    : 3     #Rotary axis type for toolplane
tooltable$   : 3     #Read for tool table and pwrtt (3 recalls pwrtt at sof)
ref_ret      : 0     #G29 / G30 return variable from Mi3
css_start_rpm : yes$ #Do direct RPM spindle start prior to CSS ?

prog_stop    : 1     #Program stop at toolchange: 0=None, 1=M01, 2 = M00
tool_info    : 1     #Output tool information?
                     #0 = Off - Do not output any tool comments or toolpable
                     #1 = Tool comments
miscopflag   : 0     #Flag for Misc Operation when its the first operation to Post

#Lathe Miscops
miscop_feedrate : 10 #Default feedrate (Units Per Minute) used for lathe misc op feed moves (override using miscops_mr3)

#Lathe Point Toolpath control
suppress_point_spindle : yes$  #Supress spindle on for lathe point toolpaths?

# --------------------------------------------------------------------------
# Machine Specific Settings
# --------------------------------------------------------------------------
#Machine axis switches, initial
y_axis_mch   : no$   #SET_BY_MD - Machine has a Y axis, 0=no, 1=yes - Set based on Axis Combination in MD
old_new_sw   : 1     #Switch old (6T), new (0T+) cycle formats, 0=old, 1=new
wcs_origin   : 0     #Always use the WCS origin for coordinates
dia_mult     : 2     #Multiplier for output on X axis (Neg. switches sign of X)
y_mult       : 1     #Multiplier for output on Y axis (Neg. switches sign of Y)
z_mult       : 1     #Multiplier for output on Z axis (Neg. switches sign of Z)
dia_shift    : 0     #Shift for output on X axis, radial entry
y_shift      : 0     #Shift for output on Y axis
z_shift      : 0     #Shift for output on Z axis
map_home     : yes$  #Use home positions as entered or map to machine axis

#C axis and Index switches
str_cax_abs  : "C"   #String address for absolute rotary axis
str_cax_inc  : "H"   #String address for incremental rotary axis
str_index    : "B"   #String address for indexer
frc_cinit    : 1     #Force C axis reset at toolchange
c_shift      : 0     #Shift for output on bottom turrets with C axis
ctol         : 270   #Tolerance in deg. of inc. move before 'rev' flag changes
ctable       : 15    #Degrees for each index step with indexing spindle
ixtol        : 0.01  #Tolerance in deg. for index error
maxfrdeg     : 2000  #Limit for feed in deg/min
frdegstp     : 10    #Step limit for rotary feed in deg/min

#Spindle switches and values
use_gear     : 0     #Output gear selection code, 0=no, 1=yes
cool_w_spd   : 0     #Output coolant with spindle code, 0=no, 1=yes - only available with V9 coolant option in MD
max_speedl0  : 3600  #Maximum spindle speed (lathe), Bottom turret/Left spindle
min_speedl0  : 20    #Minimum spindle speed
max_speedm0  : 2500  #Maximum spindle speed (mill)
min_speedm0  : 50    #Minimum spindle speed
max_speedl1  : 3600  #Maximum spindle speed (lathe), Top turret/Left spindle
min_speedl1  : 20    #Minimum spindle speed
max_speedm1  : 2500  #Maximum spindle speed (mill)
min_speedm1  : 50    #Minimum spindle speed
max_speedl2  : 3600  #Maximum spindle speed (lathe), Bottom turret/Right spindle
min_speedl2  : 20    #Minimum spindle speed
max_speedm2  : 2500  #Maximum spindle speed (mill)
min_speedm2  : 50    #Minimum spindle speed
max_speedl3  : 3600  #Maximum spindle speed (lathe), Top turret/Right spindle
min_speedl3  : 20    #Minimum spindle speed
max_speedm3  : 2500  #Maximum spindle speed (mill)
min_speedm3  : 50    #Minimum switchesspindle speed

# --------------------------------------------------------------------------------------
#Lathe canned turning settings:
#
# Set each digit of slcc_options to 0 or 1 to activate the proper canned cycle format
# based on where your machine expects the cutter comp codes for Lead in/out moves.
#
# The default value of slcc_options ("0010000100") will output the Cutter Comp codes
# inside the canned cycle. This maintains compatibility with Pre-X5 posts.
#
# To output the Cutter Comp codes outside the macro, un-pound the line for the second
# slcc_options, and comment out the first option.
# --------------------------------------------------------------------------------------
lcc_mov_mult : 2.    #Enter the move radius multiplier in X, Z for lathe canned cycle comp.

# A - Pattern, Rough, Comp lead addition, dependent on B
# B - Pattern, Rough, Comp before/after cycle
# C - Pattern, Rough, Comp in profile
#
# D - Pattern, Finish, Comp lead addition, dependent on E
# E - Pattern, Finish, Comp before/after profile
#
# F - Face/Turn, Rough, Comp lead addition, dependent on G
# G - Face/Turn, Rough, Comp before/after cycle
# H - Face/Turn, Rough, Comp in profile
#
# I - Face/Turn, Finish, Comp lead addition, dependent on J
# J - Face/Turn, Finish, Comp before/after profile

#Columns-       ABCDEFGHIJ    #Comp Output
slcc_options : "0010000100"   #Pattern & Face/Turn inside Canned Profile
#slcc_options : "1101111011"  #Pattern & Face/Turn outside Canned Profile

# --------------------------------------------------------------------------
#Machining position turret/spindle settings
# Switch strings based on turret position top/bottom-left/right and cut type.
# Turret position is based on the Mastercam settings (see lathtype).
# Strings are re-assigned for output in the routine psw_str_mult.
# The string variable sw_string holds the place position value to determine
# how to assign the strings.  Planes are relative to the view from Mastercam.
# Assign the 17 digit string following the alpha columns below:
# A - C axis, 1 = axis winds, 2 = axis signed, 3 = indexer, 4 = shortest direction
# B - Spindle direction, 0 = normal, 1 = reverse
# C - Plane 0 arc/comp, 0 = normal, 1 = switch
# D - Plane 1 arc/comp, 0 = normal, 1 = switch
# E - Plane 2 arc/comp, 0 = normal, 1 = switch
# F - Plane 0, 0 = G17, 1 = G19, 2 = G18
# G - Plane 1, 0 = G17, 1 = G19, 2 = G18
# H - Plane 2, 0 = G17, 1 = G19, 2 = G18
# Decimal (required)
# I - Plane 0, X axis, 0 = normal, 1 = switch sign from basic
# J - Plane 0, Y axis, 0 = normal, 1 = switch sign from basic
# K - Plane 0, Z axis, 0 = normal, 1 = switch sign from basic
# L - Plane 1, X axis, 0 = normal, 1 = switch sign from basic
# M - Plane 1, Y axis, 0 = normal, 1 = switch sign from basic
# N - Plane 1, Z axis, 0 = normal, 1 = switch sign from basic
# O - Plane 2, X axis, 0 = normal, 1 = switch sign from basic
# P - Plane 2, Y axis, 0 = normal, 1 = switch sign from basic
# Q - Plane 2, Z axis, 0 = normal, 1 = switch sign from basic
use_only_tl  : 1     #Use only Top turret/Left spindle settings (below) for
                     #all Mastercam turret/spindle selections
                     #When configuring for multi-spindle/turret set to 0

#Columns-       ABCDEFGH.IJKLMNOPQ #Turret/Spindle            #Path Type
scase_tl_c1  : "10000222.000000000"  #Top turret/Left spindle, Turning cut
scase_tl_c2  : "11000012.000000000"  #Top turret/Left spindle, Right Face cut
scase_tl_c_2 : "11110012.000000000"  #Top turret/Left spindle, Left Face cut
scase_tl_c3  : "10010102.000000000"  #Top turret/Left spindle, Cross cut
scase_tl_c4c : "10000111.000000000"  #Top turret/Left spindle, Y axis subs. Cycle
scase_tl_c4  : "10000222.000000000"  #Top turret/Left spindle, Y axis subs.
scase_tl_c5  : "10000222.000000000"  #Top turret/Left spindle, Multisurf Rotary

#Columns-       ABCDEFGH.IJKLMNOPQ
scase_bl_c1  : "10000222.000000000"  #Bottom turret/Left spindle, Turning cut
scase_bl_c2  : "11000012.000000000"  #Bottom turret/Left spindle, Right Face cut
scase_bl_c_2 : "11110012.000000000"  #Bottom turret/Left spindle, Left Face cut
scase_bl_c3  : "10010102.000000000"  #Bottom turret/Left spindle, Cross cut
scase_bl_c4c : "10000111.000000000"  #Bottom turret/Left spindle, Y axis subs. Cycle
scase_bl_c4  : "10000222.000000000"  #Bottom turret/Left spindle, Y axis subs.
scase_bl_c5  : "10000222.000000000"  #Bottom turret/Left spindle, Multisurf Rotary

#Columns-       ABCDEFGH.IJKLMNOPQ
scase_tr_c1  : "10000222.000000000"  #Top turret/Right spindle, Turning cut
scase_tr_c2  : "11000012.000000000"  #Top turret/Right spindle, Right Face cut
scase_tr_c_2 : "11110012.000000000"  #Top turret/Right spindle, Left Face cut
scase_tr_c3  : "10010102.000000000"  #Top turret/Right spindle, Cross cut
scase_tr_c4c : "10000111.000000000"  #Top turret/Right spindle, Y axis subs. Cycle
scase_tr_c4  : "10000222.000000000"  #Top turret/Right spindle, Y axis subs.
scase_tr_c5  : "10000222.000000000"  #Top turret/Right spindle, Multisurf Rotary

#Columns-       ABCDEFGH.IJKLMNOPQ
scase_br_c1  : "10000222.000000000"  #Bottom turret/Right spindle, Turning cut
scase_br_c2  : "11000012.000000000"  #Bottom turret/Right spindle, Right Face cut
scase_br_c_2 : "11110012.000000000"  #Bottom turret/Right spindle, Right Face cut
scase_br_c3  : "10010102.000000000"  #Bottom turret/Right spindle, Cross cut
scase_br_c4c : "10000111.000000000"  #Bottom turret/Right spindle, Y axis subs. Cycle
scase_br_c4  : "10000222.000000000"  #Bottom turret/Right spindle, Y axis subs.
scase_br_c5  : "10000222.000000000"  #Bottom turret/Right spindle, Multisurf Rotary

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
cuttype      : 0     #Flag for cut type
                     #1 = Lathe
                     #2 = Right face cut (a = 90)
                     #-2 = Left face cut  (a = -90)
                     #3 = Cross cut      (a = 0)
                     #4 = Y axis substitution
                     #5 = Multisurf Rotary 4 axis or 11 gcode
lathtype     : 0     #Lathe turret and spindle selection
                     #0 = Bottom turret/Left spindle
                     #1 = Top turret/Left spindle
                     #2 = Bottom turret/Right spindle
                     #3 = Top turret/Right spindle
lathecc      : 0     #Flag for canned turning cycle type
                     #1 = G71/G72 rough cycle
                     #2 = G73 pattern repeating cycle
                     #3 = G74/G75 groove cycle
                     #4 = Finish pass for types 1 and 2
                     #Neg.=rough and finish, Pos.=rough only
millcc       : 0     #Flag for mill conversion cycle type
millcc_flag  : 0     #Flag to indicate polar interpolation cycle is active

#Cantext activated flags
bld          : 0     #Block delete active
exact        : 0     #Exact stop active
chute        : 0     #Toggle for part catcher operation
tlstk        : 0     #Toggle for tailstock operation

#General user variables
xia          : 0     #Formated absolute value for X
yia          : 0     #Formated absolute value for Y
zia          : 0     #Formated absolute value for Z
cia          : 0     #Formated absolute value for C
copy_x       : 0     #X value copy, prevent compound operations
copy_y       : 0     #Y value copy, prevent compound operations
copy_z       : 0     #Z value copy, prevent compound operations
xa           : 0     #Absolute coordinate mapped value for X
ya           : 0     #Absolute coordinate mapped value for Y
za           : 0     #Absolute coordinate mapped value for Z
cfeed_x      : 0     #Absolute mapped/rotated unshifted value for X
cfeed_y      : 0     #Absolute mapped/rotated unshifted value for Y
cfeed_z      : 0     #Absolute mapped/rotated unshifted value for Z
xca          : 0     #Absolute unshifted value for XC
yca          : 0     #Absolute unshifted value for YC
zca          : 0     #Absolute unshifted value for ZC
sav_xa       : 0     #X saved value
sav_ya       : 0     #Z saved value
sav_za       : 0     #Z saved value
sav_xh       : 0     #X saved value
sav_yh       : 0     #Z saved value
sav_zh       : 0     #Z saved value
sav_cc_1013  : 1     #Capture value of cc_1013 flag
sav_spc      : 0     #Save spaces

conversion   : 12    #Unit conversion value, do not change
result       : 0     #Return value for functions
compok       : 1     #Flag to output cutter compensation
toolchng     : 2     #On a toolchange flag
toolchng0    : 0     #On a null toolchange flag
plane$       : -1    #Initialize plane
ipr_actv$    : -1    #Initialize active feed type
mach_plane   : 0     #Plane mapped to machine
sav_arctype  : 0     #Saved arctype$ value
sav_arctypeyz: 0     #Saved arctypeyz$ value
sav_arctypexz: 0     #Saved arctypexz$ value
breakarcss   : 0     #Store initial value of breakarcs$
breakarcsxzs : 0     #Store initial value of breakarcsxz$
breakarcsyzs : 0     #Store initial value of breakarcsyz$

sav_absinc   : 0     #Saved absolute/Incremental
spd_rev      : 0     #Flag to reverse spindle direction
sav_gcode    : 0     #Gcode saved
sav_feed     : 0     #Feed saved
sav_ipr      : 0     #IPR saved
sav_feedcc   : 0     #Feed saved, canned cycle
sav_iprcc    : 0     #IPR saved, canned cycle
sav_spdir    : 0     #Spindle direction saved
sav_omitsq   : 0     #Omitseq saved
sav_subout   : 0     #Saved subout
sav_frc_wcs  : 0     #Force work offset flag saved
sav_cutpos2  : 0     #Patch to handle cutpos2 flag through null toolchnages
cir_at_zero  : 0     #Arc center at centerline in XY plane, -1 if not plane 0
pnt_at_zero  : 0     #Position at centerline with milling
c_ax_flp     : 0     #G18 plane with C axis arcs in neg. range
home_type    : 0     #Flag for type of home location, read from misc. int.
rslt_plc     : 0     #Return value from plcval
rslt_upd     : 0     #Return value from updstr
subs_before  : 0     #Flag to indicate whether subprograms are to be output before or after main program
first_sub    : 1     #Flag used to suppress blank line before first sub that gets output with subs before main

#Drilling variables
drlgsel      : -1    #Drill Select Initialize
drillref     : -1    #Select drill reference
mdrl_dir     : 0     #Mill drill direction for boolean, 0 = face, 1 = cross
zdrl_x       : 0     #Drill point, mapped X
zdrl_y       : 0     #Drill point, mapped Y
zdrl_z       : 0     #Drill point, mapped Z

#Threading variables
nstart_cnt   : 0     #Counter for multiple threads
thd_vlen     : 0     #Incremental X move for G76 mult starts
xmaj_thd     : 0     #X major dia. from parameters
zstrt_thd    : 0     #Z start from parameters
zend_thd     : 0     #Z end from parameters
face_thd     : 0     #Face thread from parameters

#Spindle variables
max_speed    : 0     #Maximum spindle speed (set by turret definition)
min_speed    : 0     #Minimum spindle speed (set by turret definition)
speedrpm     : 0     #Spindle calculation RPM
g_speed      : 0     #Generic positive spindle speed (rpm or css)
g_spdir      : -1    #Generic spindle direction
speedx       : 0     #Test spindle calculation X position
gear_spd     : 0     #Absolute value of gear speed

# Lathe canned cycle variables
gcodecc      : 0     #Canned turning cycle gcode
y_axis       : 0     #Flag for Y axis machining (implies over center)
directcc     : 0     #Direction from parameters
dopeckcc     : 0     #Do peck from groove parameters
foundcc      : 0     #Return found from G70 read
cc_stop_fcc  : 0     #Stop output with rough only
lccdirx      : 0     #Canned cycle X vector direction
lccdirz      : 0     #Canned cycle Z vector direction
lcc_xcst     : 0     #Lathe canned cycle contour start position
lcc_ycst     : 0     #Lathe canned cycle contour start position
lcc_zcst     : 0     #Lathe canned cycle contour start position
lcc_xcend    : 0     #Lathe canned cycle contour end position
lcc_ycend    : 0     #Lathe canned cycle contour end position
lcc_zcend    : 0     #Lathe canned cycle contour end position
lcc_compok   : 0     #Flag to output cutter compensation, lathe rough canned cycles
                     #1 = Process enabled
                     #2 = Allow comp output, inhibits work offset
                     #3 = Toolchange case to allow comp output, allow work offset
lcc_leadok   : 0     #Flag to output cutter compensation lead, lathe rough canned cycles, dependent on lcc_compok
                     #1 = Process enabled
                     #2 = Indicate to process the lead
lfc_compok   : 0     #Flag to output cutter compensation, lathe canned cycle profile
lfc_leadok   : 0     #Flag to output cutter compensation lead, lathe canned cycle profile, dependent on lcc_compok
lfc_in_sub   : 0     #Flag LCC profile sub is active
anglelcc     : 0     #Pattern offset angle
ncutslcc     : 0     #Number of passes

#Vector Varibles for Mapp ing and Rotatary Calculations
#Lathe - Uses top matrix - initialize here
m1$          : 1
m5$          : 1
m9$          : 1

#C rotation vector
caxisx       : 0
caxisy       : 0
caxisz       : 1

#Mapping matrix
#Home position mapping matrix
hmtx1        : 1
hmtx2        : 0
hmtx3        : 0
hmtx4        : 0
hmtx5        : 1
hmtx6        : 0
hmtx7        : 0
hmtx8        : 0
hmtx9        : 1

#Cut type mapping matrix
mmtx1        : 1
mmtx2        : 0
mmtx3        : 0
mmtx4        : 0
mmtx5        : 1
mmtx6        : 0
mmtx7        : 0
mmtx8        : 0
mmtx9        : 1

#Side matrix
smtx1        : 0
smtx2        : 1
smtx3        : 0
smtx4        : 0
smtx5        : 0
smtx6        : 1
smtx7        : 1
smtx8        : 0
smtx9        : 0

#Cross matrix
cmtx1        : -1
cmtx2        : 0
cmtx3        : 0
cmtx4        : 0
cmtx5        : 0
cmtx6        : 1
cmtx7        : 0
cmtx8        : 1
cmtx9        : 0

#Back matrix
bmtx1        : 0
bmtx2        : -1
bmtx3        : 0
bmtx4        : 0
bmtx5        : 0
bmtx6        : 1
bmtx7        : -1
bmtx8        : 0
bmtx9        : 0

#Axis Subs matrix
amtx1        : 1
amtx2        : 0
amtx3        : 0
amtx4        : 0
amtx5        : 0
amtx6        : 1
amtx7        : 0
amtx8        : 1
amtx9        : 0

#C-axis variables for calculations
c_axistype   : 0     #1 = C axis winds-up, 2 = C axis signed absolute
                     #3 = index positioning, 4 = shortest direction (do not set here, use string)
rev_brkflag  : 0     #Revolution break flag. 0 = No break, 1 = Break every 90 or 360 degrees (see plin0$)
ipr_type     : 0     #Feedrate for Rotary, 0 = UPM, 1 = DPM
csav         : 0     #Initial c axis result from pxyzcout call
czero_csav   : 0     #Save csav when circle at zero detected
c_wnd        : 0     #Calculation for c axis position tracking (abs-wind)
prvc_wnd     : 0     #Saved cout calculation from deg., this is cabs in mpfan
rev          : 0     #C axis wind-up multiplier
prvfrdeg     : 0     #Feedrate deg/min actual
circum       : 0     #Circumference
ldelta       : 0     #Linear distance for deg/min, linear
cdelta       : 0     #Total linear and angular motion for deg/min
cdelta_calc  : 0     #Rotation calculation
cldelta      : 0     #Calculation for deg/min, linear and rotary
sav_rev      : 0     #Saved revolution counter
indx_out     : c9k   #Rotation direction calculation
sav_cabs     : 0     #Save current Cabs
fmt     17  frdeg    #Feedrate deg/min actual
fmt     20  indx_mc  #Rotation direction calculation

#Coolant variables for X style coolant
cant_pos     : 0     #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0     #Binary value for current coolant command
coolant_on   : 0     #Binary value holding the sum of all coolants currently on
coolantx     : 0     #Selector variable for coolant string selector
local_int    : 0     #Local variable for output of coolant off commands
result2      : 0     #Return value for functions
suppress     : 0     #Flag used to suppress redundant coolant on commands
all_cool_off : 0     #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0     #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

#SET BY MD - Variables to capture parameter values - use to set post switches in pset_mach
rot_axis     : 0     #Axis of rotation - 1=X, 2=Y, 3=Z
rot_type     : 1     #Rotary type - 0=signed continuous, 1=signed absolute, 2=shortest direction
rot_dir      : 0     #Rotary direction - CW is positive, 0 = false, 1 = true
rot_index    : 0     #Index or continuous - 0 = continuous, 1 = index
rot_angle    : 0     #Degrees for each index step with indexing spindle
component_type : 0   #Component type: (See documentation for complete list - )
                       #0 = MACHINE
                       #1 = STOCK_COMPONENT
                       #2 = MISC_COMPONENT
                       #3 = MACHINE_BASE_COMPONENT
                       #4 = LINEAR_AXIS_COMPONENT
                       #5 = ROTARY_AXIS_COMPONENT
                       #6 = RECT_TABLE_COMPONENT
                       #12 = CHUCK_COMPONENT
                       #24 = TOOL_SPINDLE_COMPONENT
                       #23 = ATC_COMPONENT
xpos_dir     : 0     #X Axis direction flag
ypos_dir     : 0     #Y Axis direction flag
zpos_dir     : 0     #Z Axis direction flag
axis_label   : 0     #Axis label - 1=X,2=Y,3=Z

#Plane/axis sign modifier (always 1 or -1)
pl_ax_m0x    : 1
pl_ax_m0y    : 1
pl_ax_m0z    : 1
pl_ax_m1x    : 1
pl_ax_m1y    : 1
pl_ax_m1z    : 1
pl_ax_m2x    : 1
pl_ax_m2y    : 1
pl_ax_m2z    : 1

# --------------------------------------------------------------------------
# Buffer definitions
# --------------------------------------------------------------------------
#Buffer 1, toolchange information
wc1          : 1     #Initial count for write buffer 1
rc1          : 1     #Initial count for read buffer 1
nc1          : 2     #Initial count for read buffer 1 into next record
size1        : 0     #Buffer 1 size

# Current tool information
c1_gcode     : 0     #Buffer 1
c1_xh        : 0     #Buffer 1
c1_yh        : 0     #Buffer 1
c1_zh        : 0     #Buffer 1
c1_tox       : 0     #Buffer 1
c1_toy       : 0     #Buffer 1
c1_toz       : 0     #Buffer 1
c1_cc_pos    : 0     #Buffer 1
c1_tool      : 0     #Buffer 1
c1_tloffno   : 0     #Buffer 1
c1_maxss     : 0     #Buffer 1
c1_ss        : 0     #Buffer 1
c1_spdir     : 0     #Buffer 1
c1_css_actv  : 0     #Buffer 1
c1_fr_pos    : 0     #Buffer 1
c1_ipr_actv  : 0     #Buffer 1
c1_coolant   : 0     #Buffer 1
c1_nextdc    : 0     #Buffer 1
c1_posttype  : 0     #Buffer 1
c1_cuttype   : 0     #Buffer 1
c1_lathtype  : 0     #Buffer 1
c1_gcodecc   : 0     #Buffer 1
c1_lathecc   : 0     #Buffer 1
c1_millcc    : 0     #Buffer 1
c1_y_axis    : 0     #Buffer 1
c1_x_min     : 0     #Buffer 1
c1_x_max     : 0     #Buffer 1
c1_op_id     : 0     #Buffer 1
c1_tool_op   : 0     #Buffer 1

# Next tool information
n1_gcode     : 0     #Buffer 1
n1_xh        : 0     #Buffer 1
n1_yh        : 0     #Buffer 1
n1_zh        : 0     #Buffer 1
n1_tox       : 0     #Buffer 1
n1_toy       : 0     #Buffer 1
n1_toz       : 0     #Buffer 1
n1_cc_pos    : 0     #Buffer 1
n1_tool      : 0     #Buffer 1
n1_tloffno   : 0     #Buffer 1
n1_maxss     : 0     #Buffer 1
n1_ss        : 0     #Buffer 1
n1_spdir     : 0     #Buffer 1
n1_css_actv  : 0     #Buffer 1
n1_fr_pos    : 0     #Buffer 1
n1_ipr_actv  : 0     #Buffer 1
n1_coolant   : 0     #Buffer 1
n1_nextdc    : 0     #Buffer 1
n1_posttype  : 0     #Buffer 1
n1_cuttype   : 0     #Buffer 1
n1_lathtype  : 0     #Buffer 1
n1_gcodecc   : 0     #Buffer 1
n1_lathecc   : 0     #Buffer 1
n1_millcc    : 0     #Buffer 1
n1_y_axis    : 0     #Buffer 1
n1_x_min     : 0     #Buffer 1
n1_x_max     : 0     #Buffer 1
n1_op_id     : 0     #Buffer 1
n1_tool_op   : 0     #Buffer 1

fbuf 1 0 29 0 0      #Buffer 1
# --------------------------------------------------------------------------
#Buffer 2, recall lathe canned turning cycle line numbers
wc2          : 1     #Initial count for write buffer 2
rc2          : 1     #Initial count for read buffer 2
size2        : 0     #Buffer 2 size

fcc_subid    : 0     #Buffer 2
fcc_ng70s    : 0     #Buffer 2
fcc_ng70e    : 0     #Buffer 2
fcc_compok   : 0     #Buffer 2
fcc_leadok   : 0     #Buffer 2

fbuf 2 0 5 0 0       #Buffer 2
# --------------------------------------------------------------------------
#Buffer 3, output strings for lathe canned turning cycles
wc3          : 1     #Initial count for write buffer 3
rc3          : 1     #Initial count for read buffer 3
size3        : 0     #Buffer 3 size

string3      : ""    #Buffer 3

fbuf 3 0 256 1 1     #Buffer 3
# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
stra         : "A"   #String for address A
strd         : "D"   #String for address D
stre         : "E"   #String for address E
strf         : "F"   #String for address F
stri         : "I"   #String for address I
strk         : "K"   #String for address K
strm         : "M"   #String for address M
stro         : "O"   #String for address O
strp         : "P"   #String for address P
strq         : "Q"   #String for address Q
stru         : "U"   #String for address U
strw         : "W"   #String for address W
srad         : "R"   #String for address R (radius)
srminus      : "R-"  #String for address R- (minus radius)
strs         : "S"   #String for address S
sc_minus     : "-"   #Manipulated string for signed rotary minus

#Tool note
stinsert     : " INSERT - " #String for tool notes
stinsert2    : ""    #String for tool notes

#String definitions
sg50         : "G50" #String for spindle clamp and work coordinate

#Cantext string definitions (spaces must be padded here)
sm00         : "M00" #String for stop
sm01         : "M01" #String for optional stop
strtextno    : ""    #String for cantext
strcantext   : ""    #String for cantext

#Misc G&M-Code string definitions
sm10         : "M10"  #Main spindle chuck unclamp
sm11         : "M11"  #Main spindle chuck clamp
sm210        : "M210" #Second spindle chuck unclamp
sm211        : "M211" #Second spindle chuck clamp

#Misc string definitions
sblank       : ""    #Empty string
sw_string    : ""    #String for lathe turret type settings
sopen_prn    : "("   #String for open parenthesis "("
sclose_prn   : ")"   #String for close parenthesis ")"
sopcomment   : ""    #Misc Op. Operation comment

# --------------------------------------------------------------------------
# Error message strings
# --------------------------------------------------------------------------
saxiserror   : "ERROR-WRONG AXIS OF ROTATION, ROTATE ON X AXIS OF WCS"
sindxerror   : "WARNING-INDEX ANGLE DOES NOT MATCH POST SETTING ('ctable')"
ssignerror   : "WARNING-SIGNED AXIS POSITIONING MOVE OVER 360 DEGREES"
swrkserror   : "WARNING-WORK OFFSET IS CHANGED IN A SUBPROGRAM"
stoperror    : "ERROR-AXIS SUBSTITUTION MUST USE THE TOP TOOLPLANE"
scutterror   : "ERROR-A VALID CUT TYPE WAS NOT FOUND, CHECK ROTARY SETTINGS"
sfccerror    : "ERROR-MATCHING G70 FINISH PROFILE WAS NOT FOUND"
s5drlerror   : "ERROR-5 AXIS DRILLING REQUIRES LONG CYCLE ('usecan..')"
slthrmerror  : "ERROR-ROTATE/MIRROR SUBPROGRAM NOT ALLOWED WITH LATHE PATH"
smilrmerror  : "ERROR-ROTATE/MIRROR PROGRAM ROUTINE NOT ALLOWED"
smny50error  : "ERROR-G50 AND HOME ('mi1') DOES NOT SUPPORT MULTIPLE TOOL SUBPROGRAM"
shomeserror  : "ERROR-HOME ('mi1') DOES NOT SUPPORT TRANSFORM SUBPROGRAM"
symoterror   : "WARNING-Y AXIS MOTION ENCOUNTERED.  NO Y AXIS DEFINED IN MACHINE - CHECK AXIS COMBINATION"
sstck_flip_error : "WARNING-Enable Force Tool Change in operation following Stock Flip to restart spindle and coolant after Stock Flip"

# --------------------------------------------------------------------------
# General G and M Code String select tables
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg02   : "G2"       #Circular interpolation CW
sxg03   : "G3"       #Circular interpolation CCW
# --------------------------------------------------------------------------
# Motion G code selection
sg00    : "G0"       #Rapid
sg01    : "G1"       #Linear feed
sg02    : "G2"       #Circular interpolation CW
sg03    : "G3"       #Circular interpolation CCW
sg04    : "G4"       #Dwell
sgcode  : ""         #Target string

fstrsel sg00 gcode$ sgcode 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 1
sg00_1  : "G0"       #Rapid
sg01_1  : "G1"       #Linear feed
sg02_1  : "G2"       #Circular interpolation CW
sg03_1  : "G3"       #Circular interpolation CCW
sg04_1  : "G4"       #Dwell
sgcode1 : ""         #Target string

fstrsel sg00_1 gcode$ sgcode1 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 2
sg00_2  : "G0"       #Rapid
sg01_2  : "G1"       #Linear feed
sg02_2  : "G2"       #Circular interpolation CW
sg03_2  : "G3"       #Circular interpolation CCW
sg04_2  : "G4"       #Dwell
sgcode2 : ""         #Target string

fstrsel sg00_2 gcode$ sgcode2 5 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg17   : "G17"      #XY plane code
sxg19   : "G19"      #YZ plane code
sxg18   : "G18"      #XZ plane code
swstr   : ""         #Target string

fstrsel sxg17 rslt_plc swstr 3 -1
# --------------------------------------------------------------------------
# Select work plane G code
sg17    : "G17"      #XY plane code
sg19    : "G19"      #YZ plane code
sg18    : "G18"      #XZ plane code
sgplane : ""         #Target string

fstrsel sg17 plane$ sgplane 3 -1
# --------------------------------------------------------------------------
#Select english/metric code
sg20    : "G20"      #Inch code
sg21    : "G21"      #Metric code
smetric : ""         #Target string

fstrsel sg20 met_tool$ smetric 2 -1
# --------------------------------------------------------------------------
#Select reference return code
sg28    : "G28"      #First reference point return
sg30    : "G30"      #Second reference point return
sg28ref : ""         #Target string

fstrsel sg28 ref_ret sg28ref 2 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg41   : "G41"      #Cutter compensation left
sxg42   : "G42"      #Cutter compensation right
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 0
sg40    : "G40"      #Cancel cutter compensation
sg41    : "G41"      #Cutter compensation left
sg42    : "G42"      #Cutter compensation right
sccomp  : ""         #Target string

fstrsel sg40 cc_pos$ sccomp 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 1
sg40_1  : "G40"      #Cancel cutter compensation
sg41_1  : "G41"      #Cutter compensation left
sg42_1  : "G42"      #Cutter compensation right
sccomp1 : ""         #Target string

fstrsel sg40_1 cc_pos$ sccomp1 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 2
sg40_2  : "G40"      #Cancel cutter compensation
sg41_2  : "G41"      #Cutter compensation left
sg42_2  : "G42"      #Cutter compensation right
sccomp2 : ""         #Target string

fstrsel sg40_2 cc_pos$ sccomp2 3 -1
# --------------------------------------------------------------------------
# Select canned cycle type, profile is direction of finish profile vector
sthdg32 : "G32"      #Cycle type G32
sthdg76 : "G76"      #Cycle type G76
sthdg92 : "G92"      #Cycle type G92
sthdg33 : "G32"      #Cycle type G32 with alternating position
sthdgcode : ""       #Target string

fstrsel sthdg32 thdtype$ sthdgcode 4 -1
# --------------------------------------------------------------------------
# Select canned cycle type
sg70    : "G70"      #Cycle type G70
sg71    : "G71"      #Cycle type G71
sg72    : "G72"      #Cycle type G72
sg73    : "G73"      #Cycle type G73
sg74    : "G74"      #Cycle type G74
sg75    : "G75"      #Cycle type G75
scclgcode : ""       #Target string

fstrsel sg70 gcodecc scclgcode 6 -1
# --------------------------------------------------------------------------
# Canned drill cycle string select
sg80_f  : "G81"      #drill face
sg80_fd : "G82"      #drill face w/dwell
sg81_f  : "G83"      #peck face
sg81_fd : "G83"      #peck face w/dwell
sg82_f  : "G83"      #chpbrk face
sg82_fd : "G83"      #chpbrk face w/dwell
sg83_f  : "G84"      #tap right face
sg83_fd : "G84"      #tap left face
sg84_f  : "G85"      #bore1 face
sg84_fd : "G85"      #bore1 face w/dwell
sg85_f  : "G86"      #bore2 face
sg85_fd : "G88"      #bore2 face w/dwell
sg86_f  : "G87"      #misc1 face
sg86_fd : "G87"      #misc1 face w/dwell
sg87_f  : "G8?"      #misc2 face
sg87_fd : "G8?"      #misc2 face w/dwell
sgdrillf : ""        #Target string

fstrsel sg80_f drlgsel sgdrillf 16 -1
# --------------------------------------------------------------------------
sg80_c  : "G81"      #drill cross
sg80_cd : "G82"      #drill cross w/dwell
sg81_c  : "G83"      #peck cross
sg81_cd : "G83"      #peck cross w/dwell
sg82_c  : "G87"      #chpbrk cross
sg82_cd : "G87"      #chpbrk cross w/dwell
sg83_c  : "G88"      #tap right cross
sg83_cd : "G88"      #tap left cross
sg84_c  : "G89"      #bore1 cross
sg84_cd : "G89"      #bore1 cross w/dwell
sg85_c  : "G86"      #bore2 cross
sg85_cd : "G88"      #bore2 cross w/dwell
sg86_c  : "G87"      #misc1 cross
sg86_cd : "G87"      #misc1 cross w/dwell
sg87_c  : "G8?"      #misc2 cross
sg87_cd : "G8?"      #misc2 cross w/dwell
sgdrillc : ""        #Target string

fstrsel sg80_c drlgsel sgdrillc 16 -1
# --------------------------------------------------------------------------
# Select incremental or absolute G code
sg90    : "G90"      #Absolute code
sg91    : "G91"      #Incremental code
sgabsinc : ""        #Target string

fstrsel sg90 absinc$ sgabsinc 2 -1
# --------------------------------------------------------------------------
# RPM/CSS code selection
sg97    : "G97"      #RPM
sg96    : "G96"      #CSS
sg9697  : ""         #Target string

fstrsel sg97 css_actv$ sg9697 2 -1
# --------------------------------------------------------------------------
# Feed mode G code selection
sg98    : "G98"      #UPM
sg99    : "G99"      #UPR
sgfeed  : ""         #Target string

fstrsel sg98 ipr_actv$ sgfeed 2 -1
# --------------------------------------------------------------------------
# C axis cycles
sg107   : "G107"     #C axis cylindrical interpolation enable
sg108   : "G107"     #C axis cylindrical interpolation disable
sg112   : "G112"     #C axis face polar interpolation enable
sg113   : "G113"     #C axis face polar interpolation disable
# --------------------------------------------------------------------------
#Canned drill cycle reference height
sg198   : "" #G198   #Reference at initht
sg199   : "" #G199   #Reference at refht
sgdrlref : ""        #Target string

fstrsel sg198 drillref sgdrlref 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe
sm04    : "M04"      #Spindle reverse - no coolant
sm05    : "M05"      #Spindle off     - no coolant
sm03    : "M03"      #Spindle forward - no coolant
sm14    : "M14"      #Spindle reverse - coolant
sm05c   : "M05"      #Spindle off     - coolant
sm13    : "M13"      #Spindle forward - coolant
spindle_l : ""       #Target string

fstrsel sm04 g_spdir spindle_l 6 -1
# --------------------------------------------------------------------------
# Coolant M code selection for V9 style coolant
# Note: To enable V9 style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, enable first check box
#   Output of V9 style coolant commands in this post is controlled by scoolant
sm09    : "M9"       #Coolant Off
sm08    : "M8"       #Coolant Flood
sm08_1  : "M8"       #Coolant Mist
sm08_2  : "M8"       #Coolant Tool
scoolant : ""        #Target string

fstrsel sm09 coolant$ scoolant 4 -1
# --------------------------------------------------------------------------
# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50 : "M8"                #Coolant 1 on value
scool51 : "M9"                #Coolant 1 off value
scool52 : "M7"                #Coolant 2 on value
scool53 : "M9"                #Coolant 2 off value
scool54 : "M88"               #Coolant 3 on value
scool55 : "M89"               #Coolant 3 off value
scool56 : "M8(Coolant4=ON)"   #Coolant 4 on value
scool57 : "M9(Coolant4=OFF)"  #Coolant 4 off value
scool58 : "M8(Coolant5=ON)"   #Coolant 5 on value
scool59 : "M9(Coolant5=OFF)"  #Coolant 5 off value
scool60 : "M8(Coolant6=ON)"   #Coolant 6 on value
scool61 : "M9(Coolant6=OFF)"  #Coolant 6 off value
scool62 : "M8(Coolant7=ON)"   #Coolant 7 on value
scool63 : "M9(Coolant7=OFF)"  #Coolant 7 off value
scool64 : "M8(Coolant8=ON)"   #Coolant 8 on value
scool65 : "M9(Coolant8=OFF)"  #Coolant 8 off value
scool66 : "M8(Coolant9=ON)"   #Coolant 9 on value
scool67 : "M9(Coolant9=OFF)"  #Coolant 9 off value
scool68 : "M8(Coolant10=ON)"  #Coolant 10 on value
scool69 : "M9(Coolant10=OFF)" #Coolant 10 off value
scoolantx : ""                #Target string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off : "M09" #Coolant off command output with all_cool_off

# --------------------------------------------------------------------------
# Table rotation direction, index
sindx_cw  : "M22"    #Rotate CW code
sindx_ccw : "M21"    #Rotate CCW code
sindx_mc  : ""       #Target string

fstrsel sindx_cw indx_mc sindx_mc 2 -1
# --------------------------------------------------------------------------
# C axis mode
sm23    : "M23"      #C axis enable
sm24    : "M24"      #C axis disable

# --------------------------------------------------------------------------
# Tailstock M code selection
sm26    : "M26"      #Tailstock retracted
sm25    : "M25"      #Tailstock engaged
stlstk  : ""         #Target string

fstrsel sm26 tlstk stlstk 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, mill
sm52    : "M52"      #Spindle reverse - no coolant
sm55    : "M55"      #Spindle off     - no coolant
sm51    : "M51"      #Spindle forward - no coolant
sm54    : "M54"      #Spindle reverse - coolant
sm55c   : "M55"      #Spindle off     - coolant
sm53    : "M53"      #Spindle forward - coolant
spindle_m : ""       #Target string

fstrsel sm52 g_spdir spindle_m 6 -1
# --------------------------------------------------------------------------
# Chute M code selection
sm73    : "M73"      #Chute retracted
sm74    : "M74"      #Chute engaged
schute  : ""         #Target string

fstrsel sm73 chute schute 2 -1
# --------------------------------------------------------------------------
# Month selector
smon0   : ""
smon1   : "JAN."
smon2   : "FEB."
smon3   : "MAR."
smon4   : "APR."
smon5   : "MAY."
smon6   : "JUN."
smon7   : "JUL."
smon8   : "AUG."
smon9   : "SEP."
smon10  : "OCT."
smon11  : "NOV."
smon12  : "DEC."
smonth  : ""         #Target string

fstrsel smon0 month$ smonth 13 -1
# --------------------------------------------------------------------------
# Define the gear selection code
flktbl  1       3       #Lookup table definition - table no. - no. entries
        40      0       #Low gear range
        41      400     #Med gear range
        42      2250    #Hi gear range

# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
#Default english/metric position format statements
fs2 1   0.7 0.6     #Decimal, absolute, 7 place, default for initialize (:)
fs2 2   0.4 0.3     #Decimal, absolute, 4/3 place
fs2 3   0.4 0.3d    #Decimal, delta, 4/3 place
#Common format statements
fs2 4   1 0 1 0     #Integer, not leading
fs2 5   2 0 2 0l    #Integer, force two leading
fs2 6   3 0 3 0l    #Integer, force three leading
fs2 7   4 0 4 0l    #Integer, force four leading
fs2 9   0.1 0.1     #Decimal, absolute, 1 place
fs2 10  0.2 0.2     #Decimal, absolute, 2 place
fs2 11  0.3 0.3     #Decimal, absolute, 3 place
fs2 12  0.4 0.4     #Decimal, absolute, 4 place
fs2 13  0.5 0.5     #Decimal, absolute, 5 place
fs2 14  0.3 0.3d    #Decimal, delta, 3 place
fs2 15  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 16  0 4 0 4t    #No decimal, absolute, 4 trailing
#Default english/metric feed format statements
fs2 17  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 18  0.4 0.3     #Decimal, absolute, 4/3 place
fs2 19  0.5 0.4     #Decimal, absolute, 5/4 place
fs2 20  1 0 1 0n    #Integer, forced output

# These formats used for 'Date' & 'Time'
fs2 21  2.2 2.2lt   #Decimal, force two leading & two trailing (time2)
fs2 22  2 0 2 0t    #Integer, force trailing                   (hour)
fs2 23  0 2 0 2lt   #Integer, force leading & trailing         (min)

# This format statement is used for sequence number output
# Number of places output is determined by value for "Increment Sequence Number" in CD
# Max depth to the right of the decimal point is set in the fs statement below
fs2 24  0^7 0^7     #Decimal, 7 place, omit decimal if integer value

# --------------------------------------------------------------------------
# Toolchange / NC output Variable Formats
# --------------------------------------------------------------------------
fmt  "T" 7  toolno      #Tool number
fmt  "G" 4  g_wcs       #WCS G address
fmt  "P" 4  p_wcs       #WCS P address
fmt  "S" 4  speed       #Spindle Speed
fmt  "M" 4  gear        #Gear range
fmt  "S" 4  maxss$      #RPM spindle speed
# --------------------------------------------------------------------------
fmt  "N" 24  n$         #Sequence number
fmt  "X" 2  xabs        #X position output
fmt  "Y" 2  yabs        #Y position output
fmt  "Z" 2  zabs        #Z position output
fmt  "U" 3  xinc        #X position output
fmt  "V" 3  yinc        #Y position output
fmt  "W" 3  zinc        #Z position output
fmt  "C" 11 cabs        #C axis position
fmt  "H" 14 cinc        #C axis position
fmt  "B" 4  indx_out    #Index position
fmt  "I" 3  iout        #Arc center description in X
fmt  "J" 3  jout        #Arc center description in Y
fmt  "K" 3  kout        #Arc center description in Z
fmt  "R" 2  arcrad$     #Arc Radius
fmt  "F" 18 feed        #Feedrate
fmt  "P" 11 dwell$      #Dwell
fmt  "M" 5  cantext$    #Default cantext
fmt  "C" 2  crad        #C axis start radius, G107
fmt  "H" 2  tlrad$      #C axis cancel, G112, currently using C position
# --------------------------------------------------------------------------
#Move comment (pound) to output colon with program numbers
fmt  "O" 7  progno$     #Program number
#fmt ":" 7   progno$     #Program number
fmt  "O" 7  main_prg_no$ #Program number
#fmt ":" 7   main_prg_no$ #Program number
fmt  "O" 7  sub_prg_no$ #Program number
#fmt ":" 7   sub_prg_no$  #Program number
fmt  "U" 2  sub_trnsx$  #Rotation point
fmt  "V" 2  sub_trnsy$  #Rotation point
fmt  "W" 2  sub_trnsz$  #Rotation point
# --------------------------------------------------------------------------
# Drill output
# --------------------------------------------------------------------------
fmt  "R" 2  refht_a     #Reference height
fmt  "R" 2  refht_i     #Reference height
fmt  "X" 2  initht_x    #Initial height, mapped X
fmt     2   initht_y    #Initial height, mapped Y
fmt  "Z" 2  initht_z    #Initial height, mapped Z
fmt  "X" 2  refht_x     #Reference height, mapped X
fmt     2   refht_y     #Reference height, mapped Y
fmt  "Z" 2  refht_z     #Reference height, mapped Z
fmt  "X" 2  depth_x     #Depth, mapped X
fmt     2   depth_y     #Depth, mapped Y
fmt  "Z" 2  depth_z     #Depth, mapped Z
fmt  "Q" 2  peck1$      #First peck increment (positive)
fmt     2   peck2$      #Second or last peck (positive)
fmt  "R" 2  peckclr$    #Safety distance
fmt     2   retr$       #Retract height
fmt  "Q" 2  shftdrl$    #Fine bore tool shift
# --------------------------------------------------------------------------
# Thread output
# --------------------------------------------------------------------------
fmt  "P" 2  thddepth$   #Thread height absolute
fmt  "Q" 2  thdfirst$   #First depth cut in thread
fmt  "Q" 2  thdlast$    #Last depth cut in thread
fmt  "R" 2  thdfinish$  #G76 thread finish allowance
fmt  "R" 3  thdrdlt     #Thread R delta G92 and G76
fmt  "U" 3  thd_dirx    #Incremental X move for G76 mult starts
fmt  "W" 3  thd_dirz    #Incremental Z move for G76 mult starts
fmt  "P" 5  nspring$    #Number of spring cuts
fmt     5   thdpull     #G76 thread pull off
fmt     5   thdang      #G76 threading angle
# --------------------------------------------------------------------------
# Canned cycle output format (do not change order, used by buffer 2)
# --------------------------------------------------------------------------
fmt  "U" 2  depthcc
fmt  "R" 2  clearcc
fmt  "U" 2  xstckcc
fmt  "W" 2  zstckcc
fmt  "R" 4  ncutscc
fmt     2   stepcc
fmt  "P" 4  ng70s       #P line number in canned cycle
fmt  "Q" 4  ng70e       #Q line number in canned cycle
fmt  "U" 2  g73x        #Stored offset of canned cycle rough cut G73
fmt  "V" 2  g73y        #Stored offset of canned cycle rough cut G73
fmt  "W" 2  g73z        #Stored offset of canned cycle rough cut G73
fmt  "P" 2  grvspcc
fmt  "Q" 2  grvdpcc
# --------------------------------------------------------------------------
fmt "TOOL - "       4   tnote       # Note format
fmt " OFFSET - "    4   toffnote    # Note format
# --------------------------------------------------------------------------
fmt     4   year2       #Calculated year value
fmt     21  time2       #Capture 24-hour time value into 'time2' variable
fmt     22  hour        #Hour
fmt     23  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Parameter information lookup tables, see pparameter
# --------------------------------------------------------------------------
fprmtbl 1 5 #Rough cut parameters
        13343 depthcc
        10407 clearcc
        10202 xstckcc
        10203 zstckcc
        10214 directcc

fprmtbl 2 6 #Finish cut parameters
        13341 ncutscc
        10101 depthcc
        10102 xstckcc
        10103 zstckcc
        13149 anglelcc
        13341 ncutslcc

fprmtbl 3 5 #Groove cut parameters
        13358 stepcc
        13138 directcc
        13352 dopeckcc
        10316 depthcc
        13364 clearcc

fprmtbl 104 4 #Thread cut parameters
        10811 xmaj_thd
        10813 zstrt_thd
        10814 zend_thd
        10819 face_thd

fprmtbl 17000   7   #Table Number, Size - Machine Definition parameter table
        17391   axis_label   #Axis label - 1=X,2=Y,3=Z
        17402   rot_dir      #Rotary direction
        17408   rot_index    #Index or continuous
        17409   rot_angle    #Index step
        17410   rot_type     #Rotary type
        17101   all_cool_off #First coolant off command shuts off ALL coolant options
        17102   v9_coolant   #Use V9 coolant option

# Control Definition Parameters
fprmtbl 18000   1    #Table Number, Size
#       Param   Variable to load value into
        18713   subs_before  #Subprograms output before or after main program

# Toolpath Group Parameters
fprmtbl 19000   0    #Table Number, Size
#       Param   Variable to load value into

pprep$          #Pre-process postblock - Allows post instructions after the post is parsed but before the NC and NCI file are opened.
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE) BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      rd_cd$       #Read CD Parameters
      rd_mch_ent_no$ = 0  #Read only the machine base parameters (use to collect common parameters from CNC_MACHINE_TYPE)
      rd_md$       #Read machine definition parameters
      breakarcss   = breakarcs$   #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
      breakarcsxzs = breakarcsxz$ #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
      breakarcsyzs = breakarcsyz$ #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs

pparameter$      #Information from parameters
      #"pparameter", ~prmcode$, ~sparameter$, e$
      if prmcode$ = 20103, stinsert2 = sparameter$
      result = fprm (abs(lathecc))

# --------------------------------------------------------------------------
pset_mach       #Set post switches by reading machine def parameters
      #Reset variables prior to MD read
      y_axis_mch = no$    #Reset to zero - Set from Axis Combination

      rd_mch_ent_no$ = syncaxis$  #Retrieve machine parameters based on current axis combination - read from .nci G950 line
      rd_md$       #Read machine definition parameters - calls pmachineinfo$

      #We only need these set at toolchange (and start of file).  No need to set them each time a user may call rd_md

# --------------------------------------------------------------------------
# Machine definition and control definition parameter capture:
# --------------------------------------------------------------------------
pmachineinfo$   #Machine information parameters postblock
      #rd_mach is used to call pmachineinfo postblock and read the parameters of the selected axis
      #combination machine entity set in rd_mch_ent_no.
      #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
      #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters
      #"-->pmachineinfo", ~prmcode$, "  ", ~sparameter$, e$  #Do not uncomment if being called from pprep$ - see pprep comment

      #Read parameter lookup tables -
      if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000) #Run the parameter table for Machine Definition Parameters
      if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Run the parameter table for Control Definition Parameters
      #Leave line below commented until you enter values in related lookup tables
      #if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000) #Run the parameter table for Toolpath Group Parameters

      if axis_label = 2, y_axis_mch = yes$    #Y axis in axis combination found

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
ptoolcomment    #Comment for tool
      if tool_info = 1 | tool_info = 3,
        [
        tnote = abs(t$)
        toffnote = tloffno$
        strtool$ = ucase(strtool$)
        stinsert2 = ucase(stinsert2)
        !spaces$
        spaces$ = zero
        sopen_prn, *tnote, *toffnote, sclose_prn, e$
        if posttype$ = two, #Lathe toolpath operation
          [
          if tool_op$ = 64, sopen_prn, *strtool$, sclose_prn, e$ #Drill operation
          else, sopen_prn, *strtool$, " ", *stinsert, *stinsert2, sclose_prn, e$
          ]
        else, sopen_prn, *strtool$, sclose_prn, e$ #Mill toolpath operation
        spaces$ = prv_spaces$
        ]

pcomment$       #Comment from manual entry (must call pcomment2)
      if miscopflag = zero, pheader$
      pcomment2 #Required if doing boolean 'if' logic testing!

pcomment2       #Output Comment from manual entry
      scomm$ = ucase (scomm$)
      if gcode$ = 1005, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$  #Manual entry - as comment
      if gcode$ = 1006, scomm$, e$            #Manual entry - as code
      if gcode$ = 1007, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn      #Manual entry - as comment with move NO e$
      if gcode$ = 1026, scomm$                #Manual entry - as code with move NO e$
      if gcode$ = 1008,  #Operation comment
        [
        if tool_op$ > 213 & tool_op$ < 220, sopcomment = scomm$  #Lathe Misc Operation
        else,  #Everything else
          [
          sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$
          sopcomment = sblank
          ]
        ]
      if gcode$ = 1051, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$  #Machine name
      if gcode$ = 1052, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$  #Group comment
      if gcode$ = 1053, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$  #Group name
      if gcode$ = 1054, sopen_prn, no_spc$, scomm$, no_spc$, sclose_prn, e$  #File Descriptor

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
ptime           #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader$         #Start of file
      if miscopflag = zero,
      [
      if subs_before, " ", e$ #header character is output from peof when subs are output before main
        else, "%", e$
      sav_spc = spaces$
      spaces$ = 0
      #*progno$, " (", sprogname$, sclose_prn, e$
      *progno$, e$
      sopen_prn, "PROGRAM NAME - ", sprogname$, sclose_prn, e$
      sopen_prn, "DATE=DD-MM-YY - ", date$, " TIME=HH:MM - ", time$, sclose_prn, e$ #Date and time output Ex. 12-02-05 15:52
      #sopen_prn, "DATE - ", month$, "-", day$, "-", year$, sclose_prn, e$  #Date output as month,day,year - Ex. 02-12-05
      #sopen_prn, "DATE - ", *smonth, " ", day$, " ", *year2, sclose_prn, e$ #Date output as month,day,year - Ex. Feb. 12 2005
      #sopen_prn, "TIME - ", time$, sclose_prn, e$  #24 hour time output - Ex. 15:52
      #sopen_prn, "TIME - ", ptime sclose_prn, e$  #12 hour time output 3:52 PM
      spathnc$ = ucase(spathnc$)
      smcname$ = ucase(smcname$)
      stck_matl$ = ucase(stck_matl$)
      snamenc$ = ucase(snamenc$)
      sopen_prn, "MCX FILE - ", *smcpath$, *smcname$, *smcext$, sclose_prn, e$
      sopen_prn, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, sclose_prn, e$
      sopen_prn, "MATERIAL - ", *stck_matl$, sclose_prn, e$
      spaces$ = sav_spc
      pbld, n$, *smetric, e$
      miscopflag = one
      ]
      !sub_seq_typ$

lsof0$           #Start of file for tool zero, lathe
      lsof$

lsof$            #Start of file for non-zero tool number, lathe
      sav_cc_1013 = cc_1013$
      ltlchg$

msof0$           #Start of file for tool zero, mill
      msof$

msof$            #Start of file for non-zero tool number, mill
      mtlchg$

ltlchg$          #Toolchange, lathe
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcc_capture   #Capture LCC ends, stop output RLCC
      c_rcc_setup$  #Setup LCC on first 60000
      plcc_lead_begin  #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$       #Position multi-tool sub, sets inc. current if G54...
      ptoolcomment
      comment$
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position
          pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], "W0.", e$
          toolno = t$ * 100 + zero
          if home_type = m_one, pbld, n$, *sgcode, *toolno, e$
          else, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      toolno = t$ * 100 + tloffno$
      pbld, n$, *sgcode, *toolno, e$
      pbld, n$, pfsgplane, e$
      pcaxis_off_l  #Postblock for lathe transition
      pcom_moveb    #Reset machine position, set inc. from last position
      pcan
      pspindle
      if opcode$ <> 106 | (opcode$ = 106 & suppress_point_spindle = no$),  #Do not enable spindle for point toolpath
        [
        if css_actv$,
          [
          if css_start_rpm, prpm  #Direct RPM startup for programmed CSS
          else, pcssg50, pcss  #NO RPM start - just output the CSS
          ]
        else, prpm  #Direct RPM was programmed
        ]
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pcan1, pbld, n$, psccomp, *sgcode, pwcs, pfxout, pyout, pfzout,
        pscool, strcantext, e$
      plcc_lead_end #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      if (opcode$ <> 106 | (opcode$ = 106 & suppress_point_spindle = no$)) & css_start_rpm,  #Do not enable spindle for point toolpath
        pcssg50, pcss  #CSS output AFTER a G97S???? RPM spindle startup
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      !op_id$, !lturret$, !tool_op$, prv_millcc = zero
      prev_spindle = spindle_no$  #Save spindle used in this operation

mtlchg$          #Toolchange, mill
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      ptoolcomment
      comment$

      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position/reference
          pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], "W0.", e$
          toolno = t$ * 100 + zero
          if home_type = m_one, pbld, n$, *sgcode, *toolno, e$
          else, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      toolno = t$ * 100 + tloffno$
      if millcc, cabs = zero, cinc = zero  #Force C0 if G12.1/G07.1
      pbld, n$, *sgcode, *toolno, e$
      pbld, n$, pfsgplane, e$
      pcom_moveb    #Reset machine position, set inc. from last position
      pcaxis_on_m   #Postblock for mill transition
      pcan
      if millcc, cabs = zero, cinc = zero  #Force C0 if G12.1/G07.1
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pcan1, pbld, n$, *sgcode, pwcs, pfxout, pyout, pfzout, strcantext, e$
      pbld, n$, pfcout, e$
      pindex
      pbld, n$, pscool, e$
      pspindle
      prpm
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      if millcc, pmillccb #Set mill conversion
      gcode$ = sav_gcode
      toolchng = zero
      !lturret$, !op_id$, !cuttype, !mill5$, !millcc
      prev_spindle = spindle_no$  #Save spindle used in this operation

ltlchg0$         #Call from NCI null tool change, lathe
      toolchng0 = one
      copy_x = vequ(x$)
      c_rcc_setup$  #Setup LCC on first 60000
      plcc_lead_begin  #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from last position
      if tool_op$ = 67 & prv_tool_op$ = 65,  #Cutoff and previous op was Lathe Point - misc ops do not update prv_tool_op$
        [
        cutoff_proc = one  #Cutting off and tool was pre-positioned
        if lturret$, toolend_flag = zero  #Do not execute ptoolend until second spindle has retracted
        ]
      if cutoff_proc,  #Stock Advance/Cutoff with tool already loaded
        [
        *e$
        if omitseq$ & seq_no_type,  #Sequence number output
          [
          sav_n = n$
          if seq_no_type = two, #Set n$ = tool number
            [
            if t$ > 990, n$ = t$ - 990  #If calling empty pocket
            else, n$ = t$
            ]
          *n$, e$
          if seq_no_type = two, n$ = sav_n
          ]
        ]
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan
      toolno = t$ * 100 + tloffno$
      pbld, n$, toolno, e$
      pbld, n$, psgplane, e$
      pcaxis_off_l  #Postblock for lathe transition
      pspindle
      pnullspindle
      pbld, n$, pscool, e$
      if home_type > one & workofs$ <> prv_workofs$,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, psgcode, pwcs, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]

      #Output cutter comp before each finish pass of
      if gcode$ = one, plinout
      else, prapidout
      plcc_lead_end  #Use sav_xa to position with comp. LCC
      pcom_movea
      toolchng0 = zero
      c_msng$ #Single tool subprogram call
      !op_id$, !cuttype, !tool_op$, !lturret$, prv_millcc = zero
      prev_spindle = spindle_no$  #Save spindle used in this operation

mtlchg0$         #Call from NCI null tool change, mill
      toolchng0 = one
      if prv_millcc & (not(millcc) | cuttype <> prv_cuttype | (millcc & spindle_no$ <> prv_spindle_no$)),
        [
        pmillcca #End mill conversion
        prv_millcc = zero
        ]
      copy_x = vequ(x$)
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan
      pbld, n$, toolno, e$
      pbld, n$, psgplane, e$
      pspindle
      pcaxis_on_m   #Postblock for mill transition
      pnullspindle
      pbld, n$, pscool, e$
      if home_type > one & workofs$ <> prv_workofs$,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, psgcode, pwcs, pfxout, pfyout, pfzout, pfcout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      pindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if millcc,
        [
        pmillccb  #Set mill conversion
        pcom_moveb
        ]
      if gcode$ = one, plinout
      else, prapidout

      pcom_movea    #Update previous, pcan2
      toolchng0 = zero
      c_msng$       #Single tool subprogram call
      !lturret$, !op_id$, !cuttype, !mill5$, !millcc
      prev_spindle = spindle_no$  #Save spindle used in this operation

pq$              #Setup post based on switch settings
      result = newfs(11, cdelta_calc)  #Format for 3 place precision

pmiscreal$      #Call on misc reals
      if tooltable_active$ | toolchng <> 2, # 1011 call on tool table re-read and normal process
        [
        if tooltable_active$,
          [
          rc1 = one
          size1 = rbuf (one, zero)
          if cc_1013$ = zero, cc_pos$ = zero
          ]
        if rc1 < size1, preadcur_nxt
        if lathecc = three | c1_tool_op = 62,
          [
          sav_cc_1013 = cc_1013$
          cc_1013$ = zero
          ]
        ]

ptoolend$        #Read from buffer 1 for prv_, current and next tool info
                 #end tool here, current and next valid
      if toolend_flag,
        [
        sav_rev = rev #Axis Sub does not update to rev
        pcan
        if n1_gcode <> 1000,
          [
          toolno = t$ * 100 + zero
          if millcc,
            [
            pmillcca  #End mill conversion
            ]
          sav_gcode = gcode$
          gcode$ = zero
          if v9_coolant, [coolant$ = zero, pbld, n$, pscool, e$]
          if all_cool_off,
            [
            #all coolant off with a single off code here
            if coolant_on, pbld, n$, sall_cool_off, e$
            coolant_on = zero
            ]
          else,
            [
            local_int = zero
            coolantx = zero
            while local_int < 20 & coolant_on > 0,
              [
              coolantx = and(2^local_int, coolant_on)
              local_int = local_int + one
              if coolantx > zero,
                [
                coolantx = local_int
                pbld, n$, scoolantx, e$
                ]
              coolantx = zero
              ]
            coolant_on = zero
            ]
          if posttype$ = two, pl_retract
          else, pm_retract
          if n1_gcode <> 1003,
            [
            if prog_stop = 1, pbld, n$, *sm01, e$
            if prog_stop = 2, pbld, n$, *sm00, e$
            ]
          gcode$ = sav_gcode
          ]
        else, #Null toolchange
          [
          if n1_posttype <> posttype$, pcan1, pbld, n$, pnullstop, strcantext, e$
          ]
        pcan2
        #Update current variables to prv_ needed in comparisons
        !posttype$
        ]

pl_retract      #Retract tool based on next tool gcode, lathe (see ptoolend)
      cc_pos$ = zero
      if home_type = one,
        [
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, *toolno, e$
        pbld, n$, pnullstop, strcantext, e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one, pbld, n$, *toolno, e$
        pcan1, pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], "W0.",
          pnullstop, strcantext, e$
        cutoff_proc = zero  #Reset flag if we are retracted
        if home_type > m_one, pbld, n$, *toolno, e$
        ]

pm_retract      #Retract tool based on next tool gcode, mill (see ptoolend)
      if home_type = one,
        [
        pmap_home   #Get home position, xabs
        if frc_cinit, cabs = zero
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, protretinc,
          *toolno, strcantext, e$
        pbld, n$, pnullstop, e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one, pbld, n$, *toolno, e$
        pcan1, pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], "W0.",
          protretinc, pnullstop, strcantext, e$
        if home_type > m_one, pbld, n$, *toolno, e$
        ]

protretinc      #Reset the C axis revolution counter
      if frc_cinit,
        [
        rev = zero
        sav_rev = zero
        cabs = zero
        csav = zero
        c_wnd = zero
        prvc_wnd = zero
        indx_out = zero
        if c_axistype = one | c_axistype = four,
          [
          if home_type = one, pfcout
          else,
            [
            cinc = zero
            *cinc
            ]
          ]
        else,
          [
          pindxcalc
          if c_axistype = three,
            [
            indx_out = cabs
            e$, pbld, n$, pindex
            ]
          else, pfcout
          ]
        !csav, !cabs, !c_wnd
        ]

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool
      ptoolend$
      comment$
      n$, "M30", e$
      if subs_before, #Merge subs before main program
        [             #At this point, the NC / Main program level is blank (Main prg was written to ext with subs before)
        subout$ = zero
        "%", e$
        mergesub$     #Merge transform subs
        clearsub$
        mergeaux$     #Merge non-transform subs
        clearaux$
        mergeext$     #Merge NC / Main program
        clearext$
        ]
      else,           #Merge subs after main program
        [             #At this point, the NC / Main program is written (Main prg was written to NC level with subs after)
        mergesub$
        clearsub$
        mergeaux$
        clearaux$
        ]
      subout$ = zero
      "%", e$

pwcs            #G54+ coordinate setting at toolchange
      if home_type > one,
        [
        sav_frc_wcs = force_wcs
        # Force off for these cases
        if sub_level$ > zero | lcc_compok = two, force_wcs = zero
        if workofs$ <> prv_workofs$ | (force_wcs & toolchng),
          [
          if sub_level$, result = mprint(swrkserror)
          if workofs$ < six,
            [
            g_wcs = workofs$ + 54
            *g_wcs
            ]
          else,
            [
            p_wcs = workofs$ - five
            "G54.1", *p_wcs
            ]
          ]
        force_wcs = sav_frc_wcs
        !workofs$
        ]

#Rc1 is used to flag the SOF, rc1 = two at SOF
pcaxis_off_l    #Toolchange C axis disable, lathe, check prv_ to current
      if rc1 > two & prv_posttype$ <> two, pbld, n$, *sm24, e$

pcaxis_on_m     #Toolchange C axis enable, mill, check prv_ to current
      if (rc1 = two | prv_posttype$ = two),
        [
        pbld, n$, *sm23, e$
        if nextdc$ = three, pbld, n$, "M49", e$  #Disable tap
        ]

pgear           #Use spindle gear range, find gear from RPM at X min.
      if use_gear = one,
        [
        if lathtype = zero | lathtype = two, x_min$ = c1_x_max
        else, x_min$ = c1_x_min
        x_min$ = x_min$ + c1_tox  #Correction for workshift
        if x_min$ = zero, x_min$ = 0.001
        if css_actv$ = zero, gear_spd = speedrpm
        else, gear_spd = (conversion * g_speed) / (pi$ * abs(x_min$) * two)
        gear = frange(one, gear_spd)
        *gear
        ]

prpm            #Output for start spindle
      speed = speedrpm
      if posttype$ = two,  #Lathe mode spindle
        [
        if speed = zero,
          pbld, n$, *spindle_l, e$  #RPM = '0', output just an 'M05'
        else,
          pbld, n$, *sg97, *speed, *spindle_l, pgear, e$
        ]
      else,    #Milling mode spindle
        [
        #result = nwadrs(strp, speed) #Different letter than 'S' for mill spindle?
        pbld, n$, *sg97, *speed, *spindle_m, e$
        result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$

prpmnull       #Output for RPM at NULL tlchg (don't force spindle 'M' code)
      speed = speedrpm
      if posttype$ = two,
        pbld, n$, *sg97, *speed, spindle_l, pgear, e$  # Lathe mode spindle
      else,
        [  #Milling mode spindle
         #result = nwadrs(strp, speed) #Different letter than 'S' for mill spindle?
         pbld, n$, *sg97, *speed, spindle_m, e$
         result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$


pcssg50         #Output Constant surface speed clamp
      if css_actv$, pbld, n$, *sg50, *maxss$, e$

pcss            #Output Constant surface speed
      speed = g_speed
      if css_actv$, pbld, n$, *sg9697, *speed, spindle_l, !css_actv$, e$
      !speed

#Toolchange setup, spindle output, pspindle must be called first
pnullspindle  #Null toolchange and dwell spindle change, g_speed is input
      if prv_css_actv$ <> css_actv$ | prv_g_spdir <> g_spdir | prv_speed <> g_speed | prev_spindle <> spindle_no$ | cutoff_proc,
        [
        if prev_spindle <> spindle_no$ | cutoff_proc,  #If we have switched spindles or this is the cutoff operation
          [
          if opcode$ <> 106,  #Do not enable spindle for point toolpath
            [
            if css_actv$,
              [
              if css_start_rpm & toolchng, prpm  #Direct RPM startup for programmed CSS
              else, pcssg50, pcss  #NO RPM start - just output the CSS
              ]
            else, prpm  #Direct RPM was programmed
            ]
          ]
        else,  #Same spindle
          [
          #Test for coolant OFF (with 'cool_w_spd' mode enabled)
          if posttype$ = two & cool_w_spd <> zero
            & coolant$ = zero & prv_coolant$ > zero, pbld, n$, pscool, e$
          #Switch G97/G96 or direction at null or dwell
          #Stop the spindle if direction changes
          if (prv_g_spdir <> g_spdir) & abs(prv_g_spdir - g_spdir) <> three,
            pbld, n$, pnullstop, e$
          if css_actv$,
            [
            speed = g_speed
            pnullg50
            if prv_speed <> speed | prv_css_actv$ <> css_actv$, pcss
            ]
          else,
            [
            if (prv_speed <> g_speed | prv_g_spdir <> g_spdir | prv_css_actv$ <> css_actv$)
              & g_speed, prpmnull
            ]
          ]
        ]
      else, pnullg50

pnullg50      #Change G50 clamp speed at null or dwell
      if prv_maxss$ <> maxss$ & css_actv$, pcssg50

pnullstop     #Stop spindle at null, dwell or tool end
      sav_spdir = g_spdir
      if cool_w_spd = zero, g_spdir = one
      else, g_spdir = one + (fsg2(coolant$) * three)
      if posttype$ = two, spindle_l
      else, spindle_m
      g_spdir = sav_spdir

pspindle        #Spindle speed calculations for RPM
      if maxss$ = zero | maxss$ > max_speed, maxss$ = max_speed

      if css_actv$,
        [
        #Spindle speed calculations for strt_spd w/CSS
        speedx = abs(xa)
        if opcode$ = 104, speedx = abs(c1_x_min)
        if opcode$ = 105, speedx = abs(tcr$)
        if speedx < 0.001,speedx = 0.001
        speedrpm = (conversion * g_speed) / (pi$ * speedx * two)
        ]
      else, speedrpm = g_speed
      #zero indicates spindle off (not a mistake)
      if speedrpm,
        [
        if speedrpm > maxss$, speedrpm = maxss$
        if speedrpm < min_speed, speedrpm = min_speed
        ]
      #Spindle speed for RPM with lathe drill, thread
      if opcode$ = 104 | opcode$ = 105, css_actv$ = zero
      if css_actv$ = zero, g_speed = speedrpm

pset_g_speed    #Set the spindle control variables from the read variables
      g_speed = abs(ss$)
      if cool_w_spd, g_spdir = fsg3(spdir$) + (fsg2(coolant$) * 3)
      else, g_spdir = fsg3(spdir$)
      if g_speed = zero, g_spdir = one # if RPM = '0', output 'M05'
      if spd_rev, pswtchspin

pswtchspin      #Reverse spindle direction
      if g_spdir > two, g_spdir = abs (g_spdir - five) + three
      else, g_spdir = abs (g_spdir - two)

preadcur_nxt    #Read current and next tool record
      c1_gcode = rbuf (one, rc1)     #Current tool record
      #Place buffered variables in post global variables
      cuttype = c1_cuttype
      lathtype = c1_lathtype
      lathecc = c1_lathecc
      gcodecc = c1_gcodecc
      y_axis = c1_y_axis
      millcc = c1_millcc
      n1_gcode = rbuf (one, nc1)     #Next tool record
      if cuttype = one, cc_1013$ = one
      else, cc_1013$ = zero
      if lathecc = zero, compok = one
      else, compok = zero

ptlchg1002$      #Call at actual toolchange with tlchng_aft
      whatline$ = four #Required for vector toolpaths
      pset_mach   #Set rotary switches by reading machine def parameters
      pmatrix_su
      pmap_plane
      pset_turret
      pset_g_speed
      toolend_flag = one
      if rcc_flg$ = zero, sub_seq_typ$ = prv_sub_seq_typ$
      if gcode$ = 1000,
        [
        #Null toolchange
        if millcc & prv_mi4$ = mi4$, cutpos2$ = sav_cutpos2
        if cc_stop_fcc & rcc_flg$ = six, no_nc_out$ = one
        ]
      else,
        [
        #Toolchange and Start of file
        if gcode$ = 1002,
          [
          #Actual toolchange
          preset_mod
          ]
        prv_xia = vequ (c1_xh)
        prv_feed = c9k
        pnt_at_zero = zero
        ]
      if millcc,
        [
        if cuttype = four,
          [
          crad = rotdia$/two
          ]
        else,
          [
          breakarcs$   = zero
          breakarcsxz$ = zero
          breakarcsyz$ = zero
          ]
        ]
      iout = zero
      kout = zero
      !mi4$

preset_mod    #Reset the mode flags and map during motion blocks
      breakarcs$   = breakarcss
      breakarcsxz$ = breakarcsxzs
      breakarcsyz$ = breakarcsyzs
      cir_at_zero = zero
      linarc$ = zero
      brklinestype$ = zero

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------

ptool_insp      #Tool inspection point
      #Modify following lines to customize output for tool inspection points
      if posttype$ = two, #Lathe tool inspection point
        [
        "(TOOL INSPECTION POINT - POST CUSTOMIZATION MAY BE REQUIRED)", e$
        if prmcode$ = 29999, #Only output tool insp comment if one was entered with this insp point
          [
          sparameter$ = ucase(sparameter$)
          pbld, n$, *sm00, sopen_prn, sparameter$, sclose_prn, e$
          ]
        else, pbld, n$, *sm00, e$      #Output just the stop if no comment
        pbld, n$, *sgcode, *toolno, e$ #Restate tool number
        pbld, n$, pfsgplane, e$        #Restate plane code
        prpm # Output programmed RPM   #Restate spindle
        prv_feed = c9k                 #Set prv_values to c9k to force them out with next moves
        prv_gcode$ = c9k
        prv_workofs$ = c9k
        if coolant$, prv_coolant$ = c9k
        ]
      else, #Mill tool inspection point
        pbld, n$, *sm00, "(TOOL INSPECTION POINT - POST CUSTOMIZATION REQUIRED)", e$

prapidout       #Output to NC, linear movement - rapid
      if lathecc = zero,
        [
        if millcc_flag & (abs(cuttype) = four | abs(cuttype) = two) & cutpos2$ = zero,  #Polar interpolation is active & Y-axis subs or Right face or Left face & before start point of operation geometry
          [
          if abs(cuttype) = four,  #Y-axis substitution, output C first on separate line
            [
            pcan1, pbld, n$, pexct, psgcode, pcout, e$
            pbld, n$, pexct, pxout, pyout, pzout, pscool, strcantext, e$
            ]
          else,  #Right or Left face cut, output Z last on separate line
            [
            pcan1, pbld, n$, pexct, psgcode, pxout, pyout, pcout, pscool, strcantext, e$
            pbld, n$, pexct, psgcode, pzout, e$
            ]
          ]
        else,
          [
          pcan1, pbld, n$, psgplane, pexct, psgcode, psccomp, pwcs, pxout, pyout,
          pzout, pcout, pscool, strcantext, e$
          ]
        ]
      else,  #Lathe canned turning cycle
        [
        pcan1, pbld, n$, pexct, psgcode, psccomp, pxout, pyout, pzout, pcout, pscool, strcantext, e$
        ]
      if rpd_typ$ = 7, ptool_insp      #Tool inspection point

plinout         #Output to NC, linear movement - feed
      pcan1, pbld, n$, psgplane, sgfeed, pexct, psgcode, psccomp, pwcs, pxout,
        pyout, pzout, pcout, pfr, pscool, strcantext, e$
      if rpd_typ$ = 7, ptool_insp      #Tool inspection point

pcirout         #Output to NC, circular interpolation
      pcan1, pbld, n$, psgplane, sgfeed, pexct, psgcode, psccomp, pxout,
        pyout, pzout, pcout, parc, pfr, pscool, strcantext, e$

pl_ncoutput     #Movement output
      #pcc_capture   #Capture LCC ends, stop output RLCC
      pcan
      c_rcc_setup$  #Setup LCC on first 60000
      plcc_lead_begin  #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from last position
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      plcc_lead_end   #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2

pm_ncoutput     #Movement output
      if millcc, pmillccb #Set mill conversion
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      pindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      pcom_movea    #Update previous, pcan2
      ppos_pnt_zero #Update to detect point at zero

pdwl_spd$        #Output to NC, spindle, dwell changes
      pset_g_speed
      pspindle
      comment$
      pnullspindle
      pcan
      pdwell1
      else, pcan1, pbld, n$, strcantext, e$
      pcan2

mrapid$          #Output to NC of linear movement - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pzrapid$         #Linear movement in Z axis only - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pz$              #Linear movement in Z axis only - at feedrate, mill
      copy_x = vequ(x$)
      pm_ncoutput

mlin$            #Output to NC of linear movement - feed, mill
      copy_x = vequ(x$)
      pm_ncoutput

mcir$            #Output to NC of circular interpolation, mill
      pshft_map_ijk
      copy_x = vequ(x$)
      pm_ncoutput

lrapid$          #Rapid linear movement, lathe
      copy_x = vequ(x$)
      pl_ncoutput

llin$            #Linear line movement - at feedrate, lathe
      copy_x = vequ(x$)
      pl_ncoutput

lcir$            #Circular interpolation, lathe
      pshft_map_ijk
      copy_x = vequ(x$)
      pl_ncoutput

pmx$             #Output to NC of Multisurf Rotary, mill
      copy_x = vequ(x$)
      pm_ncoutput

#Pre-process rotary motion control flags, mill
pmx0$            #5 ax Drill
      if cuttype = five,
        [
        if drill5$ = one, z$ = initht$ * z_mult
        else,
          [
          if fr$ = -2, gcode$ = zero
          else, gcode$ = one
          ]
        ]

plin0$           #Pre-linear movement postblock
      if posttype$ <> two,
        [
        preset_mod
        if y_axis = zero & c_axistype <> three,
          [
          #Set brklinestype
          if millcc = zero,
            [
            if abs(cuttype) = two, brklinestype$ = six
            if cuttype = three, brklinestype$ = four
            ]
          if cuttype = four & rev_brkflag,  #Break rotation flag (set in pcoutrev)
            [
            brklinestype$ = 11  #Break all lines, use brklineslen$ for segment length
            #brklineslen$ = pi$ * rotdia$        #Break every 360 degrees
            brklineslen$ = pi$ * rotdia$ / four  #Break every 90 degrees
            rev_brkflag = zero  #Reset flag
            ]
          ]
        ]

pcir0$           #Pre-circular interpolation postblock
      pmap_plane
      if posttype$ <> two,
        [
        preset_mod
        pshft_map_xc
        if y_axis = zero & millcc = zero,
          [
          #Set linarc, breakarcs and cir_at_zero
          if fmtrnd(xca) = zero & fmtrnd(yca) = zero,
            [
            #Set breakarcs and cir_at_zero
            breakarcs$   = zero
            breakarcsxz$ = zero
            breakarcsyz$ = zero
            #C axis move
            if mach_plane = zero,
              [
              cir_at_zero = one
              czero_csav = csav
              ]
            #Arc output
            if mach_plane = two, cir_at_zero = m_one
            ]
          if cir_at_zero = zero, linarc$ = one
          ]
        if millcc_flag & abs(cuttype = two) & plane$ > zero, linarc$ = one  #Linearize all arcs other than XY plane when G12.1
        if millcc_flag & cuttype = four,  #Force Radius output and break arcs if G07.1
          [
          breakarcs$ = one   #Break XY arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
          arctype$ = five    #XY Arc center 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5 = R no sign, 6 = R signed neg. over 180
          if plane$ > zero, linarc$ = one  #Linearize all arcs other than XY plane when G07.1
          ]
        ]
      !ynci$

# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
pdwell           #Dwell output for Pickoff/pull/Cutoff operation
      if fmtrnd(dwell$),
        [
        result = nwadrs(stru, dwell$)
        gcode$ = four
        n$, *sgcode, *dwell$, strcantext, e$
        ]

pdwell1         #Dwell output
      if fmtrnd(dwell$),
        [
        result = nwadrs(strp, dwell$)
        gcode$ = four  #for implied dwells
        pcan1, pbld, n$, *sgcode, *dwell$, strcantext, e$
        ]
pbld            #Canned text - block delete
      if bld, '/'

pfbld           #Force block delete
      "/"

psgplane        #Machining plane
      if y_axis_mch, sgplane
      !plane$

pfsgplane       #Force machining plane
      if y_axis_mch, *sgplane
      !plane$

pexct           #Canned text - exact stop
      if exact, 'G9'

psgcode         #Output the Gcode based on the current plane
      if c_ax_flp,
        [
        #Reverse arc direction for c_axis flip
        if gcode$ = two | gcode$ = three,
          [
          sav_gcode = gcode$
          gcode$ = (5 - gcode$)  #G02->G03 or G03->G02
          ]
        ]
      if plane$ = zero, `sgcode
      if plane$ = one, `sgcode1
      if plane$ = two, `sgcode2
      if c_ax_flp, gcode$ = sav_gcode

psccomp         #Output the cutter compensation based on the current plane
      if compok | lcc_compok >= two,
        [
        if plane$ = zero, sccomp
        if plane$ = one, sccomp1
        if plane$ = two, sccomp2
        ]

pfxout          #Force X axis output
      if absinc$ = zero, *xabs, !xinc
      else, *xinc, !xabs

pxout           #X output
      if absinc$ = zero, xabs, !xinc
      else, xinc, !xabs

pfyout          #Force Y axis output
      if y_axis_mch,
        [
        if absinc$ = zero, *yabs
        else, *yinc
        ]
      else, pchecky
      !yabs, !yinc

pyout           #Y output
      if y_axis_mch,
        [
        if absinc$ = zero, yabs
        else, yinc
        ]
      else, pchecky
      !yabs, !yinc

pchecky         #Y output should not happen on a c-axis lathe
      if not(toolchng) & yinc, [if (mprint(symoterror, 2) = 2), exitpost$]

pfzout          #Force Z axis output
      if absinc$ = zero, *zabs, !zinc
      else, *zinc, !zabs

pzout           #Z output
      if absinc$ = zero, zabs, !zinc
      else, zinc, !zabs

pfcout          #Force C axis output
      if posttype$ <> two & c_axistype <> three,
        [
        if c_axistype = one | c_axistype = four,
          [
          if absinc$ = zero, *cabs, !cinc
          else, *cinc, !cabs
          ]
        else, #Signed direction, no incremental
          [
          if indx_mc = zero, result = nwadrs(sc_minus, cabs)
          else, result = nwadrs(str_cax_abs, cabs)
          *cabs
          !c_wnd, !cabs, !cinc
          ]
        ]

pcout           #C axis output
      if posttype$ <> two & c_axistype <> three,
        [
        if c_axistype = one | c_axistype = four,
          [
          if absinc$ = zero, cabs, !cinc
          else, cinc, !cabs
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if prv_c_wnd <> c_wnd,
            [
            if indx_mc = zero, result = nwadrs(sc_minus, cabs)
            else, result = nwadrs(str_cax_abs, cabs)
            *cabs
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]

pindex          #Index output
      if c_axistype = three,
        [
        pbld, n$, `sindx_mc, indx_out, e$
        !cabs, !cinc
        ]

parc            #Select the arc output
      #Setup for arctype setting
      if (posttype$ = two & (larctypexz$ = one | larctypexz$ = four)) |
        (posttype$ = one &(plane$ = zero & (arctype$ = one | arctype$ = four)) |   #XY Plane
        (plane$ = one & (arctypeyz$ = one | arctypeyz$ = four)) | #YZ Plane
        (plane$ = two & (arctypexz$ = one | arctypexz$ = four))),  #XZ Plane
        [
        result = newfs(two, i$)
        result = newfs(two, j$)
        result = newfs(two, k$)
        result = newfs(two, iout)
        result = newfs(two, jout)
        result = newfs(two, kout)
        ]
      else,
        [
        result = newfs(three, i$)
        result = newfs(three, j$)
        result = newfs(three, k$)
        result = newfs(three, iout)
        result = newfs(three, jout)
        result = newfs(three, kout)
        ]

      if (posttype$ = two & (plane$ = two & larctypexz$ < five)) |
        (posttype$ = one & ((plane$ = zero & arctype$ < five) |
        (plane$ = one & arctypeyz$ < five) |
        (plane$ = two & arctypexz$ < five) | full_arc_flg$ | arc_pitch$)),
        [
        if arctype$ > four | arctypeyz$ > four | arctypexz$ > four,  #CD is set for 'R' output and we are forcing IJK
          [                                                          #Override arctype settings
          sav_arctype = arctype$, arctype$ = prv_arctype$
          sav_arctypeyz = arctypeyz$, arctypeyz$ = prv_arctypeyz$
          sav_arctypexz = arctypexz$, arctypexz$ = prv_arctypexz$
          ]
        #Arc output for IJK
        if (posttype$ = two & (plane$ = two & larctypexz$ = one)) | #XZ plane - Lathe
          (posttype$ = one & ((plane$ = zero & arctype$ = one) |    #XY Plane - Mill
          (plane$ = one & arctypeyz$ = one) |                       #YZ Plane - Mill
          (plane$ = two & arctypexz$ = one))),                      #XZ Plane - Mill
          [
          #Arc output for IJK, absolute
          iout = (iout + dia_shift) * dia_mult
          jout = (jout + y_shift) * y_mult
          kout = (kout + z_shift) * z_mult
          if c_ax_flp, iout = -iout
          ]
        else,
          [
          #Arc output for IJK, start/center
          iout = iout * (dia_mult/abs(dia_mult))
          jout = jout * y_mult
          kout = kout * z_mult
          if c_ax_flp, iout = -iout
          ]
        iout, kout, jout
        !i$, !j$, !k$
        if sav_arctype,  #Reset arctype settings
          [
          arctype$ = sav_arctype, sav_arctype = zero
          arctypeyz$ = sav_arctypeyz, sav_arctypeyz = zero
          arctypexz$ = sav_arctypexz, sav_arctypexz = zero
          ]
        ]
      else,
        [
        #Arc output for R
        if abs(sweep$)<=180 |
          (posttype$ = two & (plane$ = two & larctypexz$ = five)) |             #XZ Plane - Lathe
          (posttype$ = one & ((plane$ = zero & arctype$ = five) |               #XY Plane - Mill
          (plane$ = one & arctypeyz$ = five) |                                  #YZ Plane - Mill
          (plane$ = two & arctypexz$ = five))), result = nwadrs(srad, arcrad$)  #XZ Plane - Mill
        else, result = nwadrs(srminus, arcrad$)
        *arcrad$
        ]

pffr            #Output feedrate, force
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      *feed

pfr             #Output feedrate
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      `feed

pfr_m           #Format feedrate for mill
      result = nwadrs(strf, feed)
      result = newfs (17, feed)

pfr_l           #Format feedrate for lathe
      if opcode$ = 104,
        [
        #Format feedrate for lathe thread
        if old_new_sw = zero, result = nwadrs(stre, feed)
        result = newfs (19, feed)
        ]
      else,
        [
        result = nwadrs(strf, feed)
        result = newfs (18, feed)
        ]

pscool          #Coolant is separate code
      if v9_coolant,
        [
        if cool_w_spd = zero, scoolant
        else,
          [
          # 'cool_w_spd' mode is active
          if coolant$ = zero, scoolant  #Turn coolant OFF
          ]
        !coolant$
        ]
      else, pcan1_cool

pfscool         #Coolant is separate code, force
      if v9_coolant,
        [
        if cool_w_spd = zero, *scoolant
        !coolant$
        ]
      else, pcan1_cool

pcom_moveb      #Common motion preparation routines, before
      pshft_map_xa
      pxyzcout
      ps_inc_calc

ppos_cax_lin    #Position C if from CL
      if (prv_pnt_at_zero) & c_axistype <> three,
        [
        #Output to NC, C axis movement only - rapid deg/min
        sav_gcode = gcode$
        sav_feed = feed
        gcode$ = one
        if millcc = zero,
          [
          feed = maxfrdeg
          pbld, n$, psgcode, pfcout, pffr, e$
          ]
        else, pbld, n$, psgcode, pfcout, pfr, e$
        gcode$ = sav_gcode
        feed = sav_feed
        ]

pcom_movea      #Common motion preparation routines, after
      pcan2
      pe_inc_calc

ppos_pnt_zero   #Position C if from CL
      !pnt_at_zero
      pnt_at_zero = zero

#Mill canned cycle output
pmillccb        #Cross/Face canned cycle code, before
      if millcc_flag = zero,
        [
        millcc_flag = one
        result = newfs(two, cabs)
        result = newfs(two, cinc)
        #Cross/Face canned cycle start code
        if abs(cuttype) = two,
          [
          #Face canned cycle start code, G112 (break ramp)
          pbld, n$, *sg112, e$
          prv_xabs = c9k, prv_xinc = c9k, prv_cabs = c9k, prv_cinc = c9k
          compok = one
          ]
        else,
          [
          #Cross canned cycle start code, G107
          sav_gcode = gcode$, gcode$ = zero
          sav_cabs = cabs, cabs = zero
          pbld, n$, pfsgplane, "W0.", "H0.", e$
          cabs = sav_cabs
          pbld, n$, *sg107, *crad, e$
          gcode$ = sav_gcode
          ]
        ]

pmillcca        #Cross/Face canned cycle code, after
      if millcc_flag,
        [
        millcc_flag = zero
        result = newfs(11, cabs)
        result = newfs(14, cinc)
        !cabs, cabs = zero
        if abs(prv_cuttype) = two, pbld, n$, *sg113, e$  #Face
        else, pbld, n$, *sg108,, pfcout, e$  #Cross
        cabs = prv_cabs
        ]

# --------------------------------------------------------------------------
# Drilling
# --------------------------------------------------------------------------
pdrill0$         #Pre-drill postblock call
      if cuttype = five, #Don't allow 5 axis, rests at toolchange
        [
        usecandrill$ = zero
        usecanpeck$  = zero
        usecanchip$  = zero
        usecantap$   = zero
        usecanbore1$ = zero
        usecanbore2$ = zero
        usecanmisc1$ = zero
        usecanmisc2$ = zero
        ]
      else,
        [
        if abs(cuttype) < three, mdrl_dir = zero
        else, mdrl_dir = one
        x$ = xnci$
        y$ = ynci$
        z$ = refht$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        refht_x = vequ(xabs)
        z$ = depth$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        depth_x = vequ(xabs)
        z$ = zdrl$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        zdrl_x = vequ(xabs)
        z$ = initht$  #Initial is last
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        initht_x = vequ(xabs)
        znci$ = initht$
        ps_inc_calc
        ]

pdrlcommonb     #Canned Drill Cycle common call, before
      if gcode$ = 81,
        [
        if drillcyc$ = three, drlgsel = fsg1 (-g_speed * spdir$) + drillcyc$ * two #Tap
        else, drlgsel = fsg2 (dwell$) + drillcyc$ * two
        if initht$ <> refht$, drillref = zero
        else, drillref = one
        prv_refht_a = c9k
        prv_refht_i = c9k
        prv_dwell$  = zero
        ]
      if mdrl_dir = zero, #Set Z to depth
        [
        zia = fmtrnd(depth_z)
        zinc = zia - prv_zia
        ]
      else,               #Set X to depth
        [
        xia = fmtrnd(depth_x)
        xinc = xia - prv_xia
        ]
      xabs = vequ (depth_x)
      comment$
      pcan

pgdrlout        #Drill Gcode output
      if mdrl_dir = zero, *sgdrillf
      else, *sgdrillc

prdrlout        #R drill position
      if mdrl_dir = zero, refht_a = refht_z
      else, refht_a = refht_x
      refht_i = refht$ - initht$
      if absinc$ = zero, refht_a, !refht_i
      else, refht_i, !refht_a

ldrill$          #Canned drill cycle, lathe
      #Use this postblock to customize lathe drilling cycles 0 - 7
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, e$
      pcom_movea

lpeck$           #Canned peck drill cycle, lathe
      ldrill$

lchpbrk$         #Canned chip break cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pcan1, pbld, n$, sgcode, pzout, strcantext, e$
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      if old_new_sw = one,
        [
        pbld, n$, *sg74, *peckclr$, e$
        result = nwadrs (strq, peck1$)
        ]
      else, result = nwadrs (strk, peck1$)
      pcan1, pbld, n$, *sg74, pfzout, *peck1$, pffr, strcantext, e$
      prv_gcode$ = m_one
      if refht$ <> initht$,
        [
        gcode$ = zero
        xabs = vequ(refht_x)
        ps_inc_calc
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        pbld, n$, sgcode, pfzout, e$
        ]
      pcom_movea

ltap$            #Canned tap cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pcan1, pbld, n$, sgcode, pzout, strcantext, e$
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      opcode$ = 104 #thread address from feedrate
      pbld, n$, *sthdg32, pfzout, pffr, pnullstop, e$
      pdwell1
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pswtchspin
      pbld, n$, *sthdg32, pfzout, *spindle_l, e$
      pdwell1
      prv_gcode$ = m_one
      pbld, n$, pnullstop, e$
      pswtchspin
      if refht$ <> initht$,
        [
        gcode$ = zero
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        pbld, n$, sgcode, pfzout, *spindle_l, e$
        ]
      pbld, n$, spindle_l, e$
      opcode$ = 81 #Restore opcode
      pcom_movea

lbore1$          #Canned bore #1 cycle, lathe
      ldrill$

lbore2$          #Canned bore #2 cycle, lathe
      ldrill$

lmisc1$          #Canned misc #1 cycle, lathe
      ldrill$

lmisc2$          #Canned misc #2 cycle, lathe
      ldrill$

mdrill$          #Canned drill cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        pcout, prdrlout, dwell$, pffr, strcantext, e$
      pcom_movea

mpeck$         #Canned peck drill cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        pcout, prdrlout, *peck1$, dwell$, pffr, strcantext, e$
      pcom_movea

mchpbrk$       #Canned chip break cycle, mill
      mpeck$

mtap$          #Canned tap cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        pcout, prdrlout, pffr, strcantext, e$
      pcom_movea

mbore1$        #Canned bore #1 cycle, mill
      mdrill$

mbore2$        #Canned bore #2 cycle, mill
      mdrill$

mmisc1$        #Canned misc #1 cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        pcout, prdrlout, *shftdrl$, dwell$, pffr, strcantext, e$
      pcom_movea

mmisc2$        #Canned misc #2 cycle, mill

mdrill_2$      #Canned drill cycle repeat, mill
      pdrlcommonb
      pcan1, pbld, n$, pxout, pyout, pzout, pcout, prdrlout,
      dwell$, pfr, strcantext, e$
      pcom_movea

mpeck_2$       #Canned peck drill cycle repeat, mill
      mdrill_2$

mchpbrk_2$     #Canned chip break cycle repeat, mill
      mdrill_2$

mtap_2$        #Canned tap cycle repeat, mill
      mdrill_2$

mbore1_2$      #Canned bore #1 cycle repeat, mill
      mdrill_2$

mbore2_2$      #Canned bore #2 cycle repeat, mill
      mdrill_2$

mmisc1_2$      #Canned misc #1 cycle repeat, mill
      mdrill_2$

mmisc2_2$      #Canned misc #2 cycle repeat, mill
      mdrill_2$

pdrlcst$         #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, e$
      pcom_movea

pdrlcst_2$       #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, e$
      pcom_movea

pcanceldc$     #Cancel drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$, sgcode, "G80", strcantext, e$
      pcan2

# --------------------------------------------------------------------------
# Version 9+ MiscOps Section
# --------------------------------------------------------------------------
#Miscellaneous Variables Common to all Miscops operations
#Format as needed

#Integers
#miscops_mi1, miscops_mi2, miscops_mi3,
#miscops_mi4,  miscops_mi5, miscops_mi6,
#miscops_mi7, miscops_mi8, miscops_mi9,
#miscops_mi10

#Reals
#miscops_mr1, miscops_mr2, miscops_mr3,
#miscops_mr4, miscops_mr5, miscops_mr6,
#miscops_mr7, miscops_mr8, miscops_mr9,
#miscops_mr10
#
# --------------------------------------------------------------------------
#Format Assignments and Initializations
# --------------------------------------------------------------------------
fmt "Z" 2 stck_init_z$           #Initial Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_final_z$          #Final Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_chuk_st_z$        #Initial Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_st_x$        #Initial X axis Chuck Position (900-903)
fmt "B" 2 stck_chuk_end_z$       #Final Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_end_x$       #Final X axis Chuck Position (900-903)
fmt "B" 3 stck_chuk_st_dz$       #Destination chuck Z axis reference position before transfer (900)
fmt "U" 3 stck_chuk_st_dx$       #Destination chuck X axis reference position before transfer (900)
fmt "B" 3 stck_chuk_end_dz$      #Destination chuck Z axis reference position after transfer (900)
fmt "U" 3 stck_chuk_end_dx$      #Destination chuck X axis reference position after transfer (900)
fmt "Z" 2 stck_clear$            #Stock clearance value for stock pull operation (902)
fmt "X" 2 stck_tool_x$           #Tool X axis position for bar stop / puller (902)
fmt "Z" 2 stck_grip$             #Grip length value for stock pull operation(902)

fmt "F" 18 stck_adv_fr$          #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)
fmt "F" 18 stck_appr_fr$         #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)

fmt "F" 18 miscop_feedrate_out   #Feedrate used for lathe misc op feed moves

#Flags
stck_op$         : 0             #Stock advance operation method (902)
                                 #(0=Push stock,1=Push stock with Use Tool Stop option,2=Pull stock)
stck_spindle$    : 0             #Active spindle with stock to transfer (900-902)
                                 #0=Left Spindle,1=Right Spindle
clmp_op$         : 0             #The selected Operation mode: 0=Clamp,1=Un-clamp,2=Re-position (903)
clmp_spindle$    : 0             #Active spindle for clamp/unclamp 0=Left Spindle,1=Right Spindle (903)
tlstck_on$       : 0             #Retract or engage the tailstock (0=Retract,1=Engage) (904)

toolend_flag      : 1            #Flag to execute ptoolend sequence or not
cutoff_proc      : 0             #Flag for streamline cutoff output
                                 #0 = Off
                                 #1 = Tailor cutoff operation output for stock transfer
seq_no_type      : 1             #Sequence number output if 'output sequence numbers' is unchecked in Control Definition
                                 #0 = Off - Do not output sequence numbers
                                 #1 = Use CD settings for starting number and incrementing value - output at start of operation
                                 #2 = Set value equal to t$ - output at start of operation
sav_n            : 0             #Saved sequence number
prev_spindle     : c9k           #Spindle number used in previous operation


# --------------------------------------------------------------------------
#Postblock Section -comments only!
# --------------------------------------------------------------------------
pstck_trans$     #NCI code = 900 available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_chuk_st_dz, stck_chuk_st_dx,
      #stck_chuk_end_dz, stck_chuk_end_dx
      pheader$
#     if toolchng <> two, ptoolend$
#     toolend_flag = zero  #Do not execute ptoolend again after xfer
      pmisc_op_comment
      if miscops_mi1$,     #This will activate the Cutoff/Barpull/Pickoff utility
        [
        toolend_flag = one
        ]
      else,
        [
        !spaces$
        spaces$ = zero
        pbld, n$, "M00", e$
        if prv_spaces$ > zero, " ", e$
        if stck_spindle$ = zero, "(Xfer Part from Left Spindle)", e$
        if stck_spindle$ = one, "(Xfer Part from Right Spindle)", e$
        spaces$ = prv_spaces$
        ]
      !tool_op$

pstck_flip$      #NCI code = 901 available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x
      pheader$
      pmisc_op_comment
      if toolchng <> two, ptoolend$
      toolend_flag = zero  #Do not execute ptoolend again after xfer
      !spaces$
      spaces$ = zero
      pbld, n$, "M00", e$
      if prv_spaces$ > zero, " ", e$
      "(Flip Stock)", e$
      if n1_gcode = 1000, result = mprint(sstck_flip_error)
      spaces$ = prv_spaces$

pstck_bar_fd$    #NCI code = 902 available variables:
      #stck_spindle, stck_op, stck_clear,
      #stck_grip, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_adv_fr, stck_appr_fr
      pheader$
      pmisc_op_comment
      if stck_op$ <> one,  # if NOT using the 'Tool Stop option'
        [
        if toolchng <> two, ptoolend$
        toolend_flag = zero  #Do not execute ptoolend again after xfer
        ]
      else, toolend_flag = one  #DO execute ptoolend after xfer
      !spaces$
      spaces$ = zero
      pbld, n$, "M00", e$
      if prv_spaces$ > zero, " ", e$
      if stck_op$ = zero, "(Push stock -", e$
      if stck_op$ = one, "(Push stock with Use Tool Stop option -", e$
      if stck_op$ = two, "(Pull stock -", e$
      if stck_spindle$ = zero, " from Left Spindle)", e$
      if stck_spindle$ = one, " from Right Spindle)", e$
      spaces$ = prv_spaces$

pchuck$          #NCI code = 903 available variables:
      #clmp_spindle, clmp_op,  stck_chuk_st_z,
      #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
      pheader$
      pbld, n$, pnullstop, e$
      #Send turret home if previous op was other than lathe point or misc op.
      if prv_tool_op$ <> 65 & (prv_tool_op$ < 214 | prv_tool_op$ > 219),
        [
        toolend_flag = one
        ptoolend$
        toolend_flag = zero
        ]
      pmisc_op_comment
      if clmp_op$ = two,  #Reposition spindle
        [
        ipr_actv$ = zero  #Force G98 output
        if miscops_mi2$, gcode$ = one  #Rapid or Feed?
        else, gcode$ = zero
        if miscops_mr2$, miscop_feedrate_out = miscops_mr2$  #Set feedrate
        else, miscop_feedrate_out = miscop_feedrate
        pbld, n$, [if gcode$ = one, sgfeed], *sgcode, *stck_chuk_end_z$, [if gcode$ = one, *miscop_feedrate_out],
          "(MOVE SECOND SPINDLE TO DEFINED POINT)", e$
       ]
      else,  #Chuck Clamp/Unclamp
        [
        dwell$ = miscops_mr1$  #Set clamp dwell time
        if clmp_op$,  #Unclamp
          [
          if clmp_spindle$ = one, pbld, n$, sm210, "(OPEN CHUCK SECOND SPINDLE)", e$
          else, pbld, n$, sm10, "(OPEN CHUCK MAIN SPINDLE)", e$
          pdwell
          ]
        else,  #Clamp
          [
          if clmp_spindle$ = one, pbld, n$, sm211, "(CLOSE CHUCK SECOND SPINDLE)", e$
          else, pbld, n$, sm11, "(CLOSE CHUCK MAIN SPINDLE)", e$
          pdwell
          ]
        ]
      cutoff_proc = zero
      toolend_flag = zero
      prv_gcode$ = 903
      !tool_op$

ptailstock$      #NCI code = 904 available variables:
      #tlstck_on, stck_init_z, stck_final_z
      pheader$
      pmisc_op_comment
      if toolchng <> two, ptoolend$
      toolend_flag = zero  #Do not execute ptoolend again after xfer
      !spaces$
      spaces$ = zero
      pbld, n$, "M00", e$
      if prv_spaces$ > zero, " ", e$
      if tlstck_on$ = zero, pbld, "(Retract Tailstock)", e$
      if tlstck_on$ = one, pbld, "(Engage Tailstock)", e$
      spaces$ = prv_spaces$

psteadyrest$     #NCI code = 905 available variables:
      #stck_init_z, stck_final_z
      pheader$
      pmisc_op_comment
      if toolchng <> two, ptoolend$
      toolend_flag = zero  #Do not execute ptoolend again after xfer
      !spaces$
      spaces$ = zero
      pbld, n$, "M00", e$
      if prv_spaces$ > zero, " ", e$
      "(Position Steadyrest)", e$
      spaces$ = prv_spaces$

pmisc_op_comment   #Misc op operation comment output
      if sopcomment <> sblank,  #Output operation comment
        [
        sopen_prn, no_spc$, sopcomment, no_spc$, sclose_prn, e$
        sopcomment = sblank  #Clear comment string
        ]

# --------------------------------------------------------------------------
# Threading output
# --------------------------------------------------------------------------
pthread0$        #Pre-thread calculations
      # Calculate taper delta 'X' on Acceleration Clearance distance
      thdrdlt = (((thdx2$ - thdx3$) / abs(thdz1$ - thdz2$)) * thdzclr$)
      # Add to the original thread 'X' difference calculation
      thdrdlt = (thdrdlt + (thdx2$ - thdx3$)) * pl_ax_m0x
      thdang = rad2deg$ * thdangle$
      thd_dirx = (thdx2$ - thdx3$) * pl_ax_m0x
      thd_dirz = (thdz1$ - thdz2$) * pl_ax_m0z
      thd_vlen = thdlead$/ nstarts$
      thd_dirx = vsa (thd_vlen, thd_dirx)
      if fr_pos$, pthreadpull
      else, thdpull = zero

pthreadpull     #Pre-thread calculations
      if thdpulloff$/(fr_pos$*10) > 0.99,thdpull = 99
      else, thdpull = (thdpulloff$/(fr_pos$*10))*100

pthdext$         #Calculation override for external thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthdint$         #Calculation override for internal thread
      #thddepth = thdlead * .54127         #Calc. thread depth
      #thdflat  = thdlead * .125           #Calc. thread flat

pthdface$        #Calculation override for face thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthrg32_1$       #G32 threading first
      comment$
      gcode$ = zero
      lrapid$

pthrg32_2$       #G32 threading second
      gcode$ = zero
      lrapid$

pthrg32_3$       #G32 threading third
      copy_x = vequ(x$)
      pcom_moveb
      pcan1, pbld, n$, sgfeed, *sthdgcode, pxout, pyout, pzout, pcout, pffr,
      strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg32_4$       #G32 threading fourth
      gcode$ = zero
      lrapid$

pthrg92_1$       #G92 threading
      if thdpass$ = one, pthrg92_11

pthrg92_11      #G92 threading
      comment$
      gcode$ = zero
      lrapid$
      prv_feed = m_one
      prv_zabs = c9k
      prv_thdtype$ = m_one

pthrg92_2$       #G92 threading

pthrg92_3$       #G92 threading
      copy_x = vequ (x$)
      pcom_moveb
      pcan1, pbld, n$, sgfeed, sthdgcode, pfxout, pyout, pzout, pcout,
        [if thdrdlt & thdpass$ = one, *thdrdlt], pfr, strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg92_4$       #G92 threading

pg32e$           #G32/G92 threading end
      gcode$ = zero
      lrapid$

pthrg76_1$       #G76 threading start point
      gcode$ = zero
      lrapid$

pg76$            #G76 threading
      comment$
      gcode$ = zero
      lrapid$
      sav_xa = vequ(copy_x)
      if thdface$ = zero, copy_x = thdx3$
      else, copy_z = thdx3$
      if thdface$ = zero, copy_z = thdz2$
      else, copy_x = thdz2$
      pcom_moveb
      nstart_cnt = zero
      while nstart_cnt < nstarts$, pg76nstart
      pcom_movea
      prv_gcode$ = m_one
      copy_x = vequ(sav_xa)
      copy_x = copy_x + (thd_dirx * (nstarts$ - one))
      copy_z = copy_z + (thd_dirz * (nstarts$ - one))
      pcom_moveb
      pe_inc_calc
      !gcode$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc

pg76nstart      #G76 threading, for multiple starts
      if old_new_sw = zero, pg76old
      else, pg76new
      nstart_cnt = nstart_cnt + one
      if nstarts$ <> one & nstart_cnt <> nstarts$,
      pbld, n$, *sgcode, thd_dirx, thd_dirz, e$

pg76old         #G76 threading old style
      pbld, n$, *sthdgcode, pfxout, pfzout, *thdrdlt, *thddepth$,
        *thdfirst$, *thdang, pffr, e$

pg76new         #G76 threading new style
      pbld, n$, *sthdgcode, *nspring$, *thdpull, *thdang, *thdlast$,
        *thdfinish$, e$
      pbld, n$, *sthdgcode, pfxout, pfzout, *thddepth$, *thdfirst$,
        *thdrdlt, pffr, e$

# --------------------------------------------------------------------------
# Lathe canned cycle output
# --------------------------------------------------------------------------
pg71old         #Output G71-G72 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc,
        *depthcc, pffr, e$

pg71new         #Output G71-G72 canned cycle routines, new style, first
      if gcodecc = 1, result = nwadrs (stru, depthcc)
      else, result = nwadrs (strw, depthcc)
      pbld, n$, *scclgcode, *depthcc, *clearcc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg73old         #Output G73 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *g73x, *g73z,
        *xstckcc, *zstckcc, *ncutscc, pffr, e$

pg73new         #Output G73 canned cycle routines, new style, first
      pbld, n$, *scclgcode, *g73x, *g73z, *ncutscc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg74old         #Output G74-G75 canned cycle routines, old style
      pbld, n$, *scclgcode, pfxout, pfzout, *grvspcc, *grvdpcc,
        *clearcc, pffr, e$

pg74new         #Output G74-G75 canned cycle routines, new style, first
      pbld, n$, *scclgcode, *clearcc, e$
      pbld, n$, *sgfeed, *scclgcode, pfxout, pfzout, *grvspcc,
        *grvdpcc, pffr, e$

plcc_lead_begin #Lathe canned cycle comp lead begin process
      if lfc_in_sub = zero & (rcc_flg$ | foundcc),
        [
        if lathecc <> three,
          [
          if rcc_flg$ = one | (rcc_flg$ = 7 & foundcc = zero),
            [
            # Rough lead in, create offset position
            if lcc_leadok = one,
              [
              sav_xa = vequ(copy_x)
              #Shift for cutter comp. start position
              copy_x = copy_x + (tcr$ * lcc_mov_mult * lccdirx)
              copy_z = copy_z + (tcr$ * lcc_mov_mult * lccdirz)
              lcc_leadok = two
              ]
            ]
          else, if rcc_flg$ = six | foundcc,
            [
            # Rough lead out, inhibit force until lead
            if lcc_leadok = one, lcc_leadok = zero  # Comment '#' here for lead out in plcc_lead_end
            if lcc_leadok = one,
              [
              lcc_leadok = two
              ]
            else, if lcc_compok = one,
              [
              # Force comp on following move
              if toolchng, lcc_compok = three
              else, lcc_compok = two
              cc_pos$ = zero
              result = force(cc_pos$)
              ]
            ]
          ]
        ]
      if lathecc = three,
        [
        # Canned groove comp filtered on rapids,
        if gcode$ = zero,
          [
          if toolchng, lcc_compok = three
          else, lcc_compok = two
          ]
        ]

plcc_lead_end   #Output for lathe canned cycle cutter comp
      if lfc_in_sub = zero & (rcc_flg$ | foundcc),
        [
        if lathecc <> three,
          [
          if rcc_flg$ = one | (rcc_flg$ = 7 & foundcc = zero),
            [
            # Rough lead in, comp to original position
            if lcc_leadok = two,
              [
              pe_inc_calc           #Update previous
              copy_x = vequ(sav_xa) #Position saved in sav_xa
              pcom_moveb            #Get machine position, set inc. from previous
              lcc_compok = two      #LCC flag to allow comp, must be one to get in here
              cc_pos$ = c1_cc_pos
              result = force(cc_pos$)
              if gcode$ = zero, prapidout
              else, plinout
              # Procees state remains enabled
              lcc_compok = one
              lcc_leadok = one
              ]
            ]
          else, if rcc_flg$ = six | foundcc,
            [
            if lcc_leadok = two,
              [
              pe_inc_calc           #Update previous
              #Shift for cutter comp. cancel position
              copy_x = copy_x + (tcr$ * lcc_mov_mult * lccdirx)
              copy_z = copy_z + (tcr$ * lcc_mov_mult * lccdirz)
              pcom_moveb            #Get machine position, set inc. from previous
              lcc_compok = two      #LCC flag to allow comp, must be one to get in here
              cc_pos$ = zero
              result = force(cc_pos$)
              if gcode$ = zero, prapidout
              else, plinout
              # Disable lathe canned comp flags
              lcc_compok = zero
              lcc_leadok = zero
              ]
            else, if lcc_compok >= two,
              [
              # Disable lathe canned comp flags
              lcc_compok = zero
              lcc_leadok = zero
              ]
            ]
          if foundcc,
            [
            lcc_compok = zero
            lcc_leadok = zero
            rcc_flg$   = zero
            foundcc    = zero
            ]
          ]
        ]
      if lathecc = three,
        [
        # Canned groove comp off, prevent comp on feeds
        lcc_compok = zero
        ]

plcc_comp_only  #Output for lathe canned cycle cutter comp only
      lcc_compok = two
      result = force(cc_pos$)
      pbld, n$, psccomp, e$
      lcc_compok = one

pcc_capture     #Capture ends of canned turning path, stop output w/rough
      #Stop output in rough only lathe canned cycles
      #between rough and finish paths
      if cc_stop_fcc & rcc_flg$ = six, no_nc_out$ = one
      #Capture vector for G73 cycle
      if rpd_typ$ = six & abs(lathecc) = two,
        [
        if rcc_flg$ = one, lcc_xcst = vequ (copy_x)
        if rcc_flg$ = three, lcc_xcend = vequ (copy_x)
        ]

prcc_setup_dir  #Lathe canned cycle setup direction
      if orient$ = one|orient$ = two|orient$ = five|orient$ = six, lccdirx = one
      else, lccdirx = m_one
      if orient$ = one|orient$ = four|orient$ = five|orient$ = 8, lccdirz = one
      else, lccdirz = m_one

prcc_setup$     #Lathe canned cycle setup, capture values from rough, called by c_rcc_setup
      sav_iprcc = c1_ipr_actv
      sav_feedcc = c1_fr_pos
      prcc_setup_dir
      if lathecc > zero, cc_stop_fcc = one
      else, cc_stop_fcc = zero
      if lathecc = three,
        [
        lcc_xcst = vequ (copy_x)
        if dopeckcc = zero,
          [
          depthcc = zero
          clearcc = zero
          ]
        if directcc > one,
          [
          gcodecc = four
          grvspcc = stepcc
          grvdpcc = depthcc
          ]
        else,
          [
          gcodecc = five
          grvspcc = depthcc
          grvdpcc = stepcc
          ]
        ]
      else,
        [
        # Set flags, rough and profile, for LCC comp lead in before cycle definition, comp needs to be on
        if c1_cc_pos,
          [
          if abs(lathecc) = one,       # face/turn
            [
            if plcval(slcc_options, four) = one,    #Comp output must be enabled
              [
              lcc_compok = one
              if plcval(slcc_options, five) = one,  #Comp lead enabled
                [
                lcc_leadok = one
                ]
              ]
            ]
          else, if abs(lathecc) = two, # pattern
            [
            if plcval(slcc_options, 9) = one,       #Comp output must be enabled
              [
              lcc_compok = one
              if plcval(slcc_options, 10) = one,    #Comp lead enabled
                [
                lcc_leadok = one
                ]
              ]
            ]
          ]
        # Set profile LCC flags
        if n1_cc_pos,
          [
          if abs(lathecc) = one,       # face/turn
            [
            if plcval(slcc_options, one) = one,     #Comp output must be enabled
              [
              lfc_compok = one
              if plcval(slcc_options, two) = one,   #Comp lead enabled
                [
                lfc_leadok = one
                ]
              ]
            ]
          else, if abs(lathecc) = two, # pattern
            [
            if plcval(slcc_options, 6) = one,       #Comp output must be enabled
              [
              lfc_compok = one
              if plcval(slcc_options, 7) = one,     #Comp lead enabled
                [
                lfc_leadok = one
                ]
              ]
            ]
          ]
        ]
      sub_seq_typ$ = zero

prcc_call_st$    #Rough canned cycle start
      if lathecc <> three,
        [
        sav_subout = subout$
        sav_omitsq = omitseq$
        omitseq$ = one
        lccprg$ = one  #Open lcc file, removing all contents
        subout$ = four #Direct output to lcc file
        prv_gcode$ = m_one
        !lcc_compok, !lcc_leadok     # Update to restore for rough comp option
        if abs(lathecc) = one,       # face/turn
          [
          if plcval(slcc_options, three) = one,   #Comp output must be enabled
            [
            lcc_compok = two
            ]
          ]
        else, if abs(lathecc) = two, # pattern
          [
          if plcval(slcc_options, 8) = one,       #Comp output must be enabled
            [
            lcc_compok = two
            ]
          ]
        ]

prcc_call_end$   #Rough canned cycle end
      # Restore cc_1013 to the value it held prior to the rough
      # groove canned cycle. cc_1013 was changed in ptoolend.
      if lathecc = three | tool_op$ = 62, cc_1013$ = sav_cc_1013

      if lathecc <> three,
        [
        # Restore rough cycle comp flags
        lcc_compok = prv_lcc_compok
        lcc_leadok = prv_lcc_leadok
        omitseq$ = sav_omitsq
        #Close the lcc file
        result = fclose (sbufname3$)
        #Open the lcc file as a buffer
        #Use the size to determine the start and end sequence
        subout$ = sav_subout
        size3 = rbuf(three, zero)
        if omitseq$ = one,
          [
          ng70s = n$
          ng70e = n$ + seqinc$
          ]
        else,
          [
          if old_new_sw = zero, ng70s = n$ + seqinc$
          else, ng70s = n$ + (seqinc$ * two)
          ng70e = ng70s + (seqinc$ * (size3 - one))
          ]
        pwrite_g70
        ]

      #Setup the stock and clearance directions

      g73x = sin(anglelcc * rad2deg$) * (ncutslcc-1) * depthcc + xstckcc
      g73z = cos(anglelcc * rad2deg$) * (ncutslcc-1) * depthcc + zstckcc
      if old_new_sw = zero, g73x = g73x * pl_ax_m0x
      else, g73x = g73x * dia_mult
      g73z = g73z * pl_ax_m0z
      xstckcc =  xstckcc * dia_mult * lccdirx
      zstckcc =  zstckcc * lccdirz * pl_ax_m0z
      clearcc =  clearcc * lccdirz * pl_ax_m0z
      #Write the cycle definition
      sav_feed = feed
      sav_ipr = ipr_actv$
      feed = sav_feedcc
      ipr_actv$ = sav_iprcc

      if lathecc = three,
        [
        #Setup the previous position for inc. in G74/G75 cycle
        sav_xa = vequ(xabs) #Save the cycle end
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Recalculate incremental
        pe_inc_calc #Update previous at start
        xabs = vequ(sav_xa) #Restore the cycle end
        ps_inc_calc #Recalculate incremental
        ]
      else,
        [
        if lcc_compok = one & lcc_leadok = zero, # Rough comp on only output flag is enabled
          [
          cc_pos$ = c1_cc_pos
          plcc_comp_only
          ]
        ]

      if old_new_sw = zero,
        [
        if gcodecc < three, pg71old
        if gcodecc = three, pg73old
        if gcodecc > three, pg74old
        ]
      else,
        [
        if gcodecc < three, pg71new
        if gcodecc = three, pg73new
        if gcodecc > three, pg74new
        ]
      if lathecc = three,
        [
        #Set the cycle end position at the original start
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Position at start
        pe_inc_calc #Update previous
        ps_inc_calc #Recalculate incremental
        ]
      feed = sav_feed
      ipr_actv$ = sav_ipr
      if lathecc <> three,
        [
        #Write the cycle profile, sequence are written now
        rc3 = one
        while rc3 <= size3,
          [
          #Write the lathe canned cycle profile
          string3 = rbuf (three, rc3)
          if rc3 = two,
            [
            #Add the finish spindle speed to the first move
            speed = n1_ss
            pbld, *n$, *string3, *speed, e$
            ]
          else,
            [
            if omitseq$ = one & rc3 = size3 + one, pbld, *n$, *string3, e$
            else, pbld, n$, *string3, e$
            ]
          ]
        #Close the buffer
        result = fclose (three)
        #Remove the lcc file
        result = remove (sbufname3$)
        ]

prcc_jump_move$ #Jump to second 60000 for recall process

pfcc_call$       #G70 recall output postblock
      if cc_stop_fcc = zero,
        [
        pread_g70
        if foundcc = zero, result = mprint(sfccerror)
        ]
      no_nc_out$ = zero
      cc_stop_fcc = zero

pfcc_end$       #G70 recall output postblock
      lfc_compok = zero
      lfc_leadok = zero
      # Zero here if not active
      if not(foundcc & lcc_compok),
        [
        lcc_compok = zero
        lcc_leadok = zero
        rcc_flg$ = zero
        foundcc = zero    # Use foundcc to zero in plcc_lead_end
        ]
      lfc_in_sub = zero

pread_g70       #Read G70 recall buffer
      foundcc = zero
      size2 = rbuf (two, zero)
      wc2 = one
      while wc2 <= size2 & foundcc = zero,
        [
        fcc_subid = rbuf (two, wc2)
        if fcc_subid = sub_op_id$,
          [
          gcodecc = zero
          ng70s = fcc_ng70s
          ng70e = fcc_ng70e
          lcc_compok = fcc_compok
          lcc_leadok = fcc_leadok
          # Use rcc_flg$ to filter LCC comp when not from LCC operations, 7 triggers pfcc_end$ call
          if rcc_flg$ = zero, rcc_flg$ = 7  # Comment '#' here to filter profile recalls not part of LCC operations
          if rcc_flg$ = 7,
            [
            if lcc_leadok,
              [
              prcc_setup_dir
              sav_gcode = gcode$
              gcode$ = prv_gcode$
              pl_ncoutput
              gcode$ = sav_gcode
              ]
            else, if lcc_compok = one, # Profile comp on only output flag is enabled
              [
              plcc_comp_only
              ]
            ]
          pbld, n$, *scclgcode, *ng70s, *ng70e, e$
          foundcc = one
          lfc_in_sub = one
          ]
        ]

pwrite_g70      #Write G70 recall buffer
      fcc_subid = sub_op_id$
      fcc_ng70s = ng70s
      fcc_ng70e = ng70e
      fcc_compok = lfc_compok
      fcc_leadok = lfc_leadok
      fcc_subid = wbuf (two, rc2)

# --------------------------------------------------------------------------
#Subprogram output
#sub_trnstyp - 0=mirror, 1=rotate, 2=scale, 3=translate
#sub_trnmthd (mirror) - 0=X axis, 1=Y axis, 2=line
#sub_trnmthd (rotate) - 0=tplane, 1=tplane origin only, 2=coordinates
# --------------------------------------------------------------------------
pmiscint$        #Capture the top level absinc for subprograms
      if sub_level$ <= zero, absinc$ = mi2$
      ref_ret = mi3$
      home_type = mi1$

psub_call_m$     #Call to main level, single tool
      psub_call_trans

psub_call_mm$    #Call to main level, multiple tools
      psub_call_trans

psub_call_trans #Translate level calls from toolchange, user
      #Mirror and coordinate rotate subs not allowed with lathe
      if sub_trnstyp$ <> three & posttype$ = two, result = mprint(slthrmerror)
      if (sub_trnstyp$ = one & sub_trnmthd$ = two)
        | sub_trnstyp$ = zero, result = mprint(smilrmerror)
      sav_absinc = absinc$
      pindex
      if home_type > one,
        [
        if sub_mny_t$,
          [
          absinc$ = zero
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      else,
        [
        if home_type = one, result = mprint(shomeserror)
        else,
          [
          if sub_mny_t$, result = mprint(smny50error)
          ]
        #Apply G50 shift and correct incremental position
        if sub_sec_no$ & sub_trnstyp$ = three,
          [
          sub_trnsx$ = vmap(sub_trnsx$, hmtx1)
          sub_trnsx$ = vscl(m_one, sub_trnsx$)
          sub_trnsx$ = sub_trnsx$ * dia_mult
          sub_trnsy$ = sub_trnsy$ * y_mult
          sub_trnsz$ = sub_trnsz$ * z_mult
          pbld, n$, *sg50, *sub_trnsx$, [if y_axis_mch, *sub_trnsy$],
            *sub_trnsz$, e$
          prv_xia = vadd(prv_xia, sub_trnsx$)
          ps_inc_calc
          ]
        if toolchng = zero | home_type < two,
          [
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      absinc$ = sav_absinc
      result = nwadrs(strp, main_prg_no$)
      pbld, n$, "M98", *main_prg_no$, e$
      prv_feed = c9k #Force feed in sub

psub_st_m$       #Header in main level
      result = nwadrs(stro, main_prg_no$)
      if first_sub & subs_before, first_sub = zero #suppress blank line before first sub with subs before main
        else, " ", e$
      *main_prg_no$, e$

psub_end_m$      #End in main level
      n$, "M99", e$

psub_call_s$     #Call to sub level
      if lathecc = four, pread_g70
      else,
        [
        foundcc = zero
        result = nwadrs(strp, sub_prg_no$)
        sub_prg_no$ = sub_prg_no$ + 1000 #Add sub number offset
        pbld, n$, "M98", *sub_prg_no$, e$
        ]

psub_st_s$       #Header in sub level
      result = nwadrs(stro, sub_prg_no$)
      if first_sub & subs_before, first_sub = zero #suppress blank line before first sub with subs before main
        else, " ", e$
      *sub_prg_no$, e$

psub_end_s$      #End in sub level
      n$, "M99", e$
      pfcc_end$ # LCC in case call goes here

# --------------------------------------------------------------------------
# Canned Text
# --------------------------------------------------------------------------
pcan            #Canned text - before output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Canned text - with move
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$  = one , pcant_1
        if cant_pos2$  = one , pcant_2
        if cant_pos3$  = one , pcant_3
        if cant_pos4$  = one , pcant_4
        if cant_pos5$  = one , pcant_5
        if cant_pos6$  = one , pcant_6
        if cant_pos7$  = one , pcant_7
        if cant_pos8$  = one , pcant_8
        if cant_pos9$  = one , pcant_9
        if cant_pos10$ = one, pcant_10
        if cant_pos11$ = one, pcant_11
        if cant_pos12$ = one, pcant_12
        if cant_pos13$ = one, pcant_13
        if cant_pos14$ = one, pcant_14
        if cant_pos15$ = one, pcant_15
        if cant_pos16$ = one, pcant_16
        if cant_pos17$ = one, pcant_17
        if cant_pos18$ = one, pcant_18
        if cant_pos19$ = one, pcant_19
        if cant_pos20$ = one, pcant_20
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan1_cool      #Canned text Coolant - with move
      if cant_no$ > zero,
        [
        if cant_pos1$  = four, pcant_1
        if cant_pos2$  = four, pcant_2
        if cant_pos3$  = four, pcant_3
        if cant_pos4$  = four, pcant_4
        if cant_pos5$  = four, pcant_5
        if cant_pos6$  = four, pcant_6
        if cant_pos7$  = four, pcant_7
        if cant_pos8$  = four, pcant_8
        if cant_pos9$  = four, pcant_9
        if cant_pos10$ = four, pcant_10
        if cant_pos11$ = four, pcant_11
        if cant_pos12$ = four, pcant_12
        if cant_pos13$ = four, pcant_13
        if cant_pos14$ = four, pcant_14
        if cant_pos15$ = four, pcant_15
        if cant_pos16$ = four, pcant_16
        if cant_pos17$ = four, pcant_17
        if cant_pos18$ = four, pcant_18
        if cant_pos19$ = four, pcant_19
        if cant_pos20$ = four, pcant_20
        ]

pcan2           #Canned text - after output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Canned text - output call
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Canned text - output call
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Canned text - output call
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Canned text - output call
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Canned text - output call
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Canned text - output call
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Canned text - output call
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Canned text - output call
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Canned text - output call
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Canned text - output call
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Canned text - output call
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Canned text - output call
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Canned text - output call
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Canned text - output call
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Canned text - output call
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Canned text - output call
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Canned text - output call
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Canned text - output call
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Canned text - output call
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Canned text - output call
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
      #Assign string select type outputs
      if cant_pos < three, #cant_pos indicates canned text output
        [
        #Assign string select global variables
        if cantext$ = 3, bld = one
        if cantext$ = 4, bld = zero
        if cantext$ = 9, exact = one
        if cantext$ = 10, exact = zero
        #Build the cantext string from strings
        if cantext$ = 1, strcantext = strcantext + sm00
        if cantext$ = 2, strcantext = strcantext + sm01
        #Build the cantext string from string selects
        if cantext$ = 5 | cantext$ = 6,
          [
          if cantext$ = 5, tlstk = zero
          else, tlstk = one
          rslt_upd = updstr (stlstk)
          strcantext = strcantext + stlstk
          ]
        if cantext$ = 7 | cantext$ = 8,
          [
          if cantext$ = 7, chute = zero
          else, chute = one
          rslt_upd = updstr (schute)
          strcantext = strcantext + schute
          ]
        #Build the cantext string from cantext number
        if cantext$ > 10,
          [
          strtextno = no2str(cantext$)
          strcantext = strcantext + strm + strtextno
          ]
        ]
      else, #cant_pos indicates coolant output
        [
        coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),  # coolant off
          [
          if all_cool_off,
            [
            if coolant_on, pbld, n$, sall_cool_off, e$
            coolant_on = zero
            ]
          else,
            [
            if coolant_on > zero,
              [
              coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
              coolantx = cantext$ - 50                #Create a coolantx value for string select
              pbld, n$, *scoolantx, e$
              ]
            ]
          ]
        else,                                         #Even = on command
          [   #Determine if this coolant is already on
          local_int = zero
          coolantx = zero
          suppress = zero
          while local_int < 20 & coolant_on > zero,
            [
            result2 = and(2^local_int, coolant_on)
            local_int = local_int + one
            if result2 = coolant_bin, suppress = one
            ]
          if suppress <> 1, #Don't output an on code for a coolant that is already on
            [
            coolant_on = coolant_on + coolant_bin #Maintain binary sum of all coolants currently on
            coolantx = cantext$ - 50              #Create a coolantx value for string select
            if cant_pos = 4, *scoolantx           #Coolant "With"
              else, pbld, n$, *scoolantx, e$      #Coolant "Before" or "After"
            ]
          ]
        ]

# --------------------------------------------------------------------------
# Position calculations, generally these do not need to be modified
# --------------------------------------------------------------------------
#The variables for absolute output are xabs, yabs, zabs.
#The variables for incremental output are xinc, yinc, zinc.
#They are found from the input variables x, y, z (typically) which are
#copied to copy_x, copy_y, copy_z.  These are passed to the mapping routine
#to get raw machine coordinates xa, ya, za.  These are used in pxyxcout to
#get the output xabs, yabs, zabs.  ps_inc_calc is called to get xinc, yinc,
#zinc.  cfeed_x, cfedd_y, cfeed_z are the unshifted positions for feed
#calculations.
# --------------------------------------------------------------------------
pxyzcout      #Perform calls for mapping coordinates and shifts
      pplane_mod
      if cuttype = one, pxyzcout0                   #Turning
      if abs(cuttype) = two                         #Right/Left Face cut
        | cuttype = three, pxyzcout2                #Cross cut
      if cuttype = four, pxyzcout4                  #Y axis substitution
      if cuttype = five, pxyzcout5                  #Multisurf Rotary
      #C axis control modifications
      if posttype$ <> two,
        [
        pcoutrev
        cabs = c_wnd
        if c_axistype > one | millcc,
          [
          pindxcalc
          if c_axistype = three,
            [
            #Check if in tolerance
            cdelta = frac(abs(cabs)/ctable)
            if cdelta > ixtol & cdelta < 1-ixtol,
              result = mprint(sindxerror)
            indx_out = cabs
            ]
          if c_axistype = two, #Signed direction calculation
            [
            #Warn if a move greater than 360
            cdelta_calc = abs(prvc_wnd - c_wnd)
            cdelta_calc = fmtrnd(cdelta_calc)
            if cdelta_calc > 360, result = mprint(ssignerror)
            ]
          ]
        if y_axis = zero,
          [
          if cir_at_zero = one, gcode$ = one #only C is moving
          if cir_at_zero = m_one & (xa < zero | prv_xa < zero), c_ax_flp = one
          else, c_ax_flp = zero
          ]
        if millcc,
          [
          if fmtrnd(cabs) = 360, cabs = zero  #Always try to start at zero
          if abs(cuttype) = two, ppolar_fcyc
          ]
        ]
      pfcalc

pxyzcout0       #Lathe and machine coordinates
      cfeed_x = vequ(xa)
      csav = c$
      pax_shift
      ipr_type = zero

pxyzcout4       #Calculations for Y axis substitution (mapped)
      cfeed_x = xa + (rotdia$/two)
      cfeed_y = zero
      cfeed_z = za
      csav = ya * (360 / (pi$ * rotdia$))
      if rotaxis_dir$ = zero, csav = -csav  #Reverse output for CW direction selection
      pax_shift
      if millcc, ipr_type = zero
      else, ipr_type = one

pxyzcout2       #Polar conversion, Cross cut, Right/Left Face cut
      #Drill polar is toolplane drilling toward center
      #if not a coincident axis (Face cut)
      if (y_axis | (opcode$ = three & abs(cuttype) <> two)), pxyzcout0
      else,
        [
        cfeed_x = sqrt(xa^2 + ya^2)
        cfeed_y = zero
        cfeed_z = za
        if opcode$ = three & cuttype = three, csav = c$
        else, csav = atan2(ya, xa) + c$
        pax_shift
        ipr_type = one
        if not(millcc & abs(cuttype) = two),
          [
          if fmtrnd(xa) = zero & fmtrnd(ya) = zero & opcode$ <> three,
            pnt_at_zero = one
          ]
        ]

pxyzcout5       #Multisurf rotary axis motion
      csav = atan2(vtooly$, vtoolz$)
      axisx$ = vequ(caxisx)
      xa = rotp (-csav, xa)
      cfeed_x = vequ(xa)
      pax_shift
      csav = csav + c$
      ipr_type = one

ppolar_fcyc     #Output values for face, polar conversion cycle
      xabs = (xa + dia_shift) * dia_mult
      yabs = zero
      zabs = (za + z_shift) * z_mult
      cabs = (ya + y_shift) * y_mult
      ipr_type = zero

pax_shift       #Apply multiplier and shift positions, csav was recalculated
      xabs = (cfeed_x + dia_shift) * dia_mult
      yabs = (cfeed_y + y_shift) * y_mult
      zabs = (cfeed_z + z_shift) * z_mult
      #Apply axis shift for lower turrets
      if posttype$ <> two & (lathtype = zero | lathtype = two),
        csav = csav + c_shift
      if posttype$ = two,
        [
        yabs = zero
        csav = zero
        ]

pplane_mod    #Modify the multiplier based on plane, see psw_str_mult
      if plane$ = zero,
        [
        dia_mult = prv_dia_mult * pl_ax_m0x
        y_mult = prv_y_mult * pl_ax_m0y
        z_mult = prv_z_mult * pl_ax_m0z
        ]
      else,
        [
        if plane$ = one,
          [
          dia_mult = prv_dia_mult * pl_ax_m1x
          y_mult = prv_y_mult * pl_ax_m1y
          z_mult = prv_z_mult * pl_ax_m1z
          ]
        else, #plane = two
          [
          dia_mult = prv_dia_mult * pl_ax_m2x
          y_mult = prv_y_mult * pl_ax_m2y
          z_mult = prv_z_mult * pl_ax_m2z
          ]
        ]

pcoutrev        #Rotary axis revolution calculation (Modify for wind-up)
      if cir_at_zero = one & gcode$ > 1,
        [
        #Arcs at center position the c axis
        if cuttype = -2 | cuttype = three,
        csav = czero_csav - sweep$
        else, csav = czero_csav + sweep$
        czero_csav = csav
        ]
      #C does not move going to CL
      if pnt_at_zero, csav = prv_csav
      cdelta = fmtrnd(csav) - prv_csav  #This calculates once, for rev
      if cuttype = four & toolchng = zero & toolchng0 = zero & (c_axistype = two | c_axistype = four),  #Axis sub and signed direction or shortest direction
        [
        cdelta_calc = abs(cdelta)
        cdelta_calc = fmtrnd(cdelta_calc)
        if cdelta_calc > 360,  #Break rotary motion
          [
          rev_brkflag = one  #Break every 90 or 360 degrees (see plin0$)
          redo_proc$  #Reprocess NCI line
          ]
        ]
      while abs(cdelta) > ctol & not(cir_at_zero), #If motion exceeds ctol, add wind-up
        [
        if cdelta > zero,
          [
          rev = rev - one
          cdelta = cdelta - 360
          ]
        else,
          [
          rev = rev + one
          cdelta = cdelta + 360
          ]
        ]
      if cuttype <> four, c_wnd = rev * 360 + csav
      else, c_wnd = sav_rev * 360 + csav
      !csav
      @c_wnd
      #Now switch to c_wnd which is the absolute winding C calculation
      #Modify for shortest direction if toolchange or toolplane
      #but not with axis subs
      if c_axistype <> three,
        [
        if abs(prvc_wnd - c_wnd) > 180
          & (toolchng | (y_axis & cuttype < four)),
          [
          while abs(prvc_wnd - c_wnd) > 180,
            [
            if prvc_wnd > c_wnd, rev = rev + one
            else, rev = rev - one
            c_wnd = rev * 360 + csav
            ]
          @c_wnd
          ]
        ]

pindxcalc       #Index move calculations, direction is shortest exc. Asub
      if pnt_at_zero | cdelta = zero, indx_mc = prv_indx_mc
      else,
        [
        cdelta = fmtrnd(c_wnd) - prvc_wnd
        if cuttype = four, #Just look at the direction
          [
          if cdelta >= zero, indx_mc = one
          else, indx_mc = zero
          ]
        else,
          [
          #Phase shift delta 10 revolutions, check odd/even for direction
          if frac(int((cdelta + 3600)/180)/two), indx_mc = zero
          else, indx_mc = one
          ]
        ]
      #Set range 0-360
      while cabs < zero, cabs = cabs + 360
      while cabs > 360, cabs = cabs - 360

pfcalc          #Feedrate calculations, gcode 0 does not evaluate
      if abs(c_wnd-prvc_wnd) < vtol$ | c_axistype = three | drillcur$
      | ipr_type=zero | prv_pnt_at_zero | gcode$ = zero, pfcalc_u_min
      else, pfclc_deg_inv

pfcalc_u_min    #Feedrate unit/min
      feed = fr_pos$
      if feed > maxfeedpm, feed = maxfeedpm
      prvfrdeg = feed

pfclc_deg_inv   #Feedrate deg/min, xa and ya are assumed relative to origin
      #Average last radius to current radius
      ldelta = ((cfeed_x+prv_cfeed_x)/two)^two+((cfeed_y+prv_cfeed_y)/two)^two
      circum = sqrt(ldelta) * two * pi$
      if circum = zero, circum = c9k          #Don't allow Zero
      ldelta = (cfeed_x-prv_cfeed_x)^two+(cfeed_y-prv_cfeed_y)^two
      ldelta = sqrt(ldelta+(cfeed_z-prv_cfeed_z)^two)
      cdelta = ((abs(c_wnd - prvc_wnd))/360)*circum
      if ldelta = zero, cldelta = cdelta
      else, cldelta = sqrt(cdelta^two + ldelta^two)
      if cldelta = zero, cldelta = c9k
      #Feedrate deg/min control and calculation
      frdeg = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
      if abs(frdeg - prvfrdeg) > frdegstp | ipr_type <> prv_ipr_type,
        [
        #Control output of frdeg
        prvfrdeg = frdeg
        feed = frdeg
        ]
      if fmtrnd(frdeg) = zero, feed = fr_pos$
      if frdeg > maxfrdeg, feed = maxfrdeg

#Incremental calculations
ps_inc_calc     #Incremental calculations, start
      xia = fmtrnd(xabs)
      yia = fmtrnd(yabs)
      zia = fmtrnd(zabs)
      xinc = vsub (xia, prv_xia)
      if posttype$ <> two, ps_cinc_calc

ps_cinc_calc    #Incremental calculations, start rotary
      cia = fmtrnd(cabs)
      cinc = cia - prv_cia

pe_inc_calc     #Incremental calculations, end
      prvc_wnd = fmtrnd(c_wnd)      #Avoid updating until called explicitly
      !cfeed_x, !cfeed_y, !cfeed_z, !ipr_type  #These are used in pxyzcout
      !x$, !y$, !z$, !xa, !ya, !za
      !xia, !yia, !zia, !cia
      !cc_pos$, !cutpos2$

# --------------------------------------------------------------------------
# Mapping routines, maps input to basic machine coordinates (side view)
# --------------------------------------------------------------------------
pmatrix_su      #Setup mapping matrix
      hmtx1 = matt(m1$)
      hmtx1 = mmul(hmtx1, smtx1)
      if cuttype = one, mmtx1 = matt(m1$)
      if cuttype = two, mmtx1 = matt(smtx1)
      if cuttype = -2, mmtx1 = matt(bmtx1)
      if cuttype = three | cuttype = five, mmtx1 = matt(cmtx1)
      if cuttype = four, mmtx1 = matt(amtx1)
      mmtx1 = mmul(mmtx1, smtx1)

pshft_map_xc    #Remove workshift and map to lathe coordinates, center
      xca = vadd (xc$, tox$)  #Always shift to origin
      if plane$ = one,
        [
        result = xca
        xca = zca
        zca = yca
        yca = result
        ]
      if plane$ = two,
        [
        result = yca
        yca = zca
        zca = result
        ]
      xca = vmap (xca, mmtx1)

pshft_map_ijk    #Remove workshift and map to lathe coordinates, ijk
      if arctype$ = one, #Absolute is shifted
        [
        if wcs_origin, iout = vadd (i$, tox$)
        else, iout = vequ (i$)
        ]
      else, iout = vequ (i$)
      iout = vmap (iout, mmtx1)

pshft_map_xa     #Remove workshift and map to lathe coordinates, xyz
      if wcs_origin, xa = vadd (copy_x, tox$)
      else, xa = vequ (copy_x)
      xa = vmap (xa, mmtx1)

pmap_home     #Set the location for home position
      xa = vequ(xh$)
      if map_home,
        [
        if wcs_origin, xa = vadd(xa, tox$)
        xa = vmap(xa, hmtx1)
        ]
      pplane_mod
      pxyzcout0 #basic toolplane positioning

pmap_plane    #Map NCI plane to machine plane
      mach_plane = plane$
      #Cross
      if cuttype=3 & plane$<two, mach_plane = abs(plane$ - one)
      #Top
      if (abs(cuttype)<=one | abs(cuttype)>=4),
      mach_plane = plane$ - one
      if mach_plane = m_one, mach_plane = two

# --------------------------------------------------------------------------
# NCI file pre-read look ahead routines
# Build the toolchange buffer, sets cycle and turret flags
# --------------------------------------------------------------------------
pwrttparam$      #Information from parameters
      #"pwrttparam", ~prmcode$, ~sparameter$, e$
      if opcode$ = 104, result = fprm (opcode$)

pwrtt$           #Buffer toolchange information, tooltable = 3 calls on 1003
      if gcode$ = 1001, psetup
      pcut_cctyp
      if opcode$=104 | opcode$=105 | opcode$=three | opcode$=16, cc_pos$ = zero
      if gcode$ <> 1001, plast_recd
      pcur_recd
      if gcode$ <> 1003, cc_pos$ = zero
      !opcode$, !tool_op$

pcur_recd       #Write to the current tool record
      c1_gcode = gcode$
      pmatrix_su
      pset_turret
      pmap_home
      c1_xh = vequ(xabs)
      c1_tox = vmap (tox$, mmtx1)
      c1_cc_pos = cc_pos$
      if gcode$ <> 1003, c1_tool = abs(t$)
      else, c1_tool = zero
      c1_tloffno = tloffno$
      c1_maxss = maxss$
      c1_ss = abs(ss$)
      if cool_w_spd = zero, c1_spdir = spdir$ + one
      else, c1_spdir = (spdir$ + one) + (fsg2(coolant$) * three)
      c1_css_actv = css_actv$
      c1_fr_pos = fr_pos$
      c1_ipr_actv = ipr_actv$
      c1_coolant = coolant$
      c1_nextdc = nextdc$
      c1_posttype = posttype$
      c1_cuttype = cuttype
      c1_lathtype = lathtype
      c1_gcodecc = gcodecc
      c1_lathecc = lathecc
      c1_millcc = millcc
      c1_y_axis = y_axis
      c1_op_id = op_id$
      if opcode$ = 104,
        [
        if face_thd <> two, x_min$ = abs(xmaj_thd)
        else,
          [
          if abs(zstrt_thd) > abs(zend_thd), x_min$ = abs(zstrt_thd)
          else, x_min$ = abs(zend_thd)
          ]
        x_max$ = x_min$
        ]
      c1_gcode = wbuf (one, wc1)

plast_recd      #Update the last record(s) for min-max and point
      rc1 = wc1 - one
      c1_gcode = rbuf (one, rc1)
      if prv_opcode$ <> 104,
        [
        c1_x_min = x_min$
        c1_x_max = x_max$
        ]
      rc1 = wc1 - one               #rc1 is used to write also
      c1_gcode = wbuf (one, rc1)

pcut_cctyp      #Find the type of cut for the tool buffer
      #y_axis
      #posttype
      #cuttype
      #lathtype
      y_axis = zero
      cuttype = zero
      if posttype$ = two, cuttype = one
      else,
        [
        if mill5$, cuttype = five
        else,
          [
          if rotary_type$ = one, cuttype = four
          else,
            [
            @m1$, @m2$, @m3$, @m7$, @m8$, @m9$
            if m7$ = m_one & m8$ = zero & m9$ = zero, cuttype = -2
            if m7$ = one & m8$ = zero & m9$ = zero, cuttype = two
            if m1$ = m_one & m2$ = zero & m3$ = zero, cuttype = three
            #Mill operations, assume No rotation to be Y axis
            if rotary_type$ = zero | rotary_type$ = three, y_axis = one
            ]
          ]
        ]
      lathtype = lturret$ + spindle_no$ * two
      #Check for errors
      if rotary_type$,
        [
        if (abs(cuttype) = two & rotary_axis$ <> three)
        | (cuttype = three & rotary_axis$ <> one),
          result = mprint(saxiserror)
        if cuttype = four & tlplnno$ <> one, result = mprint(stoperror)
        ]
      else,
        [
        if cuttype = zero, result = mprint(scutterror)
        ]
      #gcodecc, determine G74/G75 direction during processing
      #lathecc
      #millcc
      gcodecc = zero
      lathecc = zero
      if tool_op$ > 201,
        [
        if tool_op$ = 202 | tool_op$ = 203,
          [
          gcodecc = one
          lathecc = one
          if tool_op$ = 203, lathecc = m_one
          ]
        else,
          [
          if tool_op$ = 204 | tool_op$ = 205,
            [
            gcodecc = two
            lathecc = one
            if tool_op$ = 205, lathecc = m_one
            ]
          else,
            [
            if tool_op$ = 206 | tool_op$ = 207,
              [
              gcodecc = three
              lathecc = two
              if tool_op$ = 207, lathecc = -2
              ]
            else,
              [
              if tool_op$ = 208,
                [
                gcodecc = four
                lathecc = three
                ]
              ]
            ]
          ]
        ]
      else, if tool_op$ = 201,
        [
        lathecc = four
        ]
      if mi4$<>zero & opcode$ <> three & (cuttype=four | abs(cuttype)=two),
         millcc = mi4$
      else, millcc = zero

psetup          #Setup post based on NCI settings
      home_type = mi1$
      sbufname3$ = spathnci$ + snamenci$ + sextlcc$ #lcc file is used to buffer lathe canned cycle output
      spathlcc$ = spathnci$
      snamelcc$ = snamenci$
      #Set metric defaults
      if met_tool$,
        [
        conversion = 1000
        vtol$ = vtol_m
        maxfeedpm = maxfeedpm_m
        ]

      #Setup for old or new style canned cycles
      if old_new_sw = one,
        [
        result = newfs (16, thddepth$)
        result = newfs (16, thdfirst$)
        result = newfs (16, thdlast$)
        result = newfs (16, thdfinish$)
        ]
      else,
        [
        result = nwadrs (stra, thdang)
        result = nwadrs (stri, thdrdlt)
        result = nwadrs (strk, thddepth$)
        result = nwadrs (strd, thdfirst$)
        #Lathe canned cycle old style conversion
        result = nwadrs (strd, depthcc)
        result = nwadrs (strd, ncutscc)
        result = nwadrs (stri, g73x)
        result = nwadrs (strk, g73z)
        result = nwadrs (stri, grvspcc)
        result = nwadrs (strk, grvdpcc)
        ]
      result = nwadrs(str_cax_abs, cabs)
      result = nwadrs(str_cax_inc, cinc)
      result = nwadrs(str_index, indx_out)
      sc_minus = str_cax_abs + sc_minus

# --------------------------------------------------------------------------
# Turret and cut type change setup, do not edit
# --------------------------------------------------------------------------
pset_turret     #Set the machine conditions and mapping based on the turret
      if lathtype = one | use_only_tl, pltype1
      else,
        [
        if lathtype = zero, pltype0
        else,
          [
          if lathtype = two, pltype2
          else, pltype3
          ]
        ]
      psw_str_mult

pltype0         #Bottom turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl0
        min_speed = min_speedl0
        sw_string = scase_bl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm0
        min_speed = min_speedm0
        sw_string = scase_bl_c2 #case two is the default
        if cuttype = -2, sw_string = scase_bl_c_2
        if cuttype = three, sw_string = scase_bl_c3
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_bl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_bl_c4
        if cuttype = five, sw_string = scase_bl_c5
        ]

pltype1         #Top turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl1
        min_speed = min_speedl1
        sw_string = scase_tl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm1
        min_speed = min_speedm1
        sw_string = scase_tl_c2 #case two is the default
        if cuttype = -2, sw_string = scase_tl_c_2
        if cuttype = three, sw_string = scase_tl_c3
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tl_c4
        if cuttype = five, sw_string = scase_tl_c5
        ]

pltype2         #Bottom turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl2
        min_speed = min_speedl2
        sw_string = scase_br_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm2
        min_speed = min_speedm2
        sw_string = scase_br_c2 #case two is the default
        if cuttype = -2, sw_string = scase_br_c_2
        if cuttype = three, sw_string = scase_br_c3
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_br_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_br_c4
        if cuttype = five, sw_string = scase_br_c5
        ]

pltype3         #Top turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl3
        min_speed = min_speedl3
        sw_string = scase_tr_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm3
        min_speed = min_speedm3
        sw_string = scase_tr_c2 #case two is the default
        if cuttype = -2, sw_string = scase_tr_c_2
        if cuttype = three, sw_string = scase_tr_c3
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tr_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tr_c4
        if cuttype = five, sw_string = scase_tr_c5
        ]

psw_str_mult    #Apply sw_string to variables and strings
      #c axis type
      c_axistype = plcval (sw_string, 8)
      #reverse spindle
      spd_rev = plcval (sw_string, 7)
      #plane 0
      rslt_plc = plcval (sw_string, 6)
       if rslt_plc = zero,
        [
        sg02 = sxg02
        sg03 = sxg03
        sg41 = sxg41
        sg42 = sxg42
        ]
      else,
        [
        sg02 = sxg03
        sg03 = sxg02
        sg41 = sxg42
        sg42 = sxg41
        ]
      #plane 1
      rslt_plc = plcval (sw_string, five)
      if rslt_plc = zero,
        [
        sg02_1 = sxg02
        sg03_1 = sxg03
        sg41_1 = sxg41
        sg42_1 = sxg42
        ]
      else,
        [
        sg02_1 = sxg03
        sg03_1 = sxg02
        sg41_1 = sxg42
        sg42_1 = sxg41
        ]
      #plane 2
      rslt_plc = plcval (sw_string, four)
      if rslt_plc = zero,
        [
        sg02_2 = sxg02
        sg03_2 = sxg03
        sg41_2 = sxg41
        sg42_2 = sxg42
        ]
      else,
        [
        sg02_2 = sxg03
        sg03_2 = sxg02
        sg41_2 = sxg42
        sg42_2 = sxg41
        ]
      #plane 0
      rslt_plc = plcval (sw_string, three)
      rslt_upd = updstr (swstr)
      sg17 = swstr
      #plane 1
      rslt_plc = plcval (sw_string, two)
      rslt_upd = updstr (swstr)
      sg19 = swstr
      #plane 2
      rslt_plc = plcval (sw_string, one)
      rslt_upd = updstr (swstr)
      sg18 = swstr
      #plane 0, x axis
      rslt_plc = plcval (sw_string, m_one)
      pl_ax_m0x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -2)
      pl_ax_m0y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -3)
      pl_ax_m0z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -4)
      pl_ax_m1x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -5)
      pl_ax_m1y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -6)
      pl_ax_m1z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -7)
      pl_ax_m2x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -8)
      pl_ax_m2y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -9)
      pl_ax_m2z = -((rslt_plc * two) - one)

# --------------------------------------------------------------------------
# Post Text --  Use Control Definition Manager to modify
# --------------------------------------------------------------------------
[CTRL_MT_MILL|DEFAULT]
[misc integers]
1. "Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]"//2
2. "Abs/Inc. [0=ABS, 1=INC]"
3. "Ref. Return [0=G28,1=G30]"
4. "Mill Cyc G107/G112 [0=OFF,1/-1=ON]"
[simple drill]
1. "Drill/Counterbore"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
10. ""
11. ""
[chip break]
11. ""
[tap]
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Bore #1 "
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
7. ""
8. ""
9. ""
10. ""
[canned text]
1. "Program Stop"
2. "Optional Stop"
3. "Block Delete on"
4. "Block Delete off"
5. "Return Tailstock"
6. "Advance Tailstock"
7. "Return Chute"
8. "Advance Chute"
9. "Exact Stop on"
10. "Exact Stop off"
[CTRL_MT_LATHE|DEFAULT]
[misc integers]
1. "Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]"//2
2. "Abs/Inc. [0=ABS, 1=INC]"
3. "Ref. Return [0=G28,1=G30]"
[simple drill]
1. "Drill/Counterbore"
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
2. ""
10. ""
11. ""
[chip break]
1. "Chip break (G74)"
2. ""
11. ""
[tap]
1. "Tap (G32)"
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Bore #1 "
2. ""
7. ""
8. ""
9. ""
10. ""
[bore2]
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
2. ""
8. ""
9. ""
10. ""
[misc2]
1. "Misc. #2 "
2. ""
[drill cycle 9]
2. ""
[drill cycle 10]
2. ""
[drill cycle 11]
2. ""
[drill cycle 12]
2. ""
[drill cycle 13]
2. ""
[drill cycle 14]
2. ""
[drill cycle 15]
2. ""
[drill cycle 16]
2. ""
[drill cycle 17]
2. ""
[drill cycle 18]
2. ""
[drill cycle 19]
2. ""
[drill cycle 20]
2. ""
[stock transfer custom parameters]
1. "Use Cutoff/Barpull/Pickoff utility"
2. "Reserved - Do Not Edit"
11. "Reserved - Do Not Edit"
12. "Reserved - Do Not Edit"
[chuck custom parameters]
1. "Reserved - Do Not Edit"
2. "Reposition Mode [0=Rapid,1=Feed]"
11. "Chuck Clamp/Unclamp dwell time"
12. "Feedrate Amount [0=Default >0=Value]"
[CTRL_MT_MILL|GENERIC FANUC 4X MT_LATHE]
[misc integers]
1. "Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]"//2
2. "Abs/Inc. [0=ABS, 1=INC]"
3. "Ref. Return [0=G28,1=G30]"
4. "Mill Cyc G107/G112 [0=OFF,1/-1=ON]"
[simple drill]
1. "Drill/Counterbore"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
10. ""
11. ""
[chip break]
11. ""
[tap]
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Bore #1 "
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
7. ""
8. ""
9. ""
10. ""
[canned text]
1. "Program Stop"
2. "Optional Stop"
3. "Block Delete on"
4. "Block Delete off"
5. "Return Tailstock"
6. "Advance Tailstock"
7. "Return Chute"
8. "Advance Chute"
9. "Exact Stop on"
10. "Exact Stop off"
[CTRL_MT_LATHE|GENERIC FANUC 4X MT_LATHE]
[misc integers]
1. "Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]"//2
2. "Abs/Inc. [0=ABS, 1=INC]"
3. "Ref. Return [0=G28,1=G30]"
[simple drill]
1. "Drill/Counterbore"
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
2. ""
10. ""
11. ""
[chip break]
1. "Chip break (G74)"
2. ""
11. ""
[tap]
1. "Tap (G32)"
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Bore #1 "
2. ""
7. ""
8. ""
9. ""
10. ""
[bore2]
2. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
2. ""
8. ""
9. ""
10. ""
[misc2]
1. "Misc. #2 "
2. ""
[drill cycle 9]
2. ""
[drill cycle 10]
2. ""
[drill cycle 11]
2. ""
[drill cycle 12]
2. ""
[drill cycle 13]
2. ""
[drill cycle 14]
2. ""
[drill cycle 15]
2. ""
[drill cycle 16]
2. ""
[drill cycle 17]
2. ""
[drill cycle 18]
2. ""
[drill cycle 19]
2. ""
[drill cycle 20]
2. ""
[stock transfer custom parameters]
1. "Use Cutoff/Barpull/Pickoff utility"
2. "Reserved - Do Not Edit"
11. "Reserved - Do Not Edit"
12. "Reserved - Do Not Edit"
[chuck custom parameters]
1. "Reserved - Do Not Edit"
2. "Reposition Mode [0=Rapid,1=Feed]"
11. "Chuck Clamp/Unclamp dwell time"
12. "Feedrate Amount [0=Default >0=Value]"
[CTRL_TEXT_END]
